# 项目框架

介绍下你的项目做了什么？<br>

**介绍项目的时候主动从一些关键点去介绍，比如协程调度的几种实现：go的、libco的、C++20的无栈协程、独立栈共享栈等等，说明自己技术选型的优势，再放个压测数据，才可以说明自己对项目是有思考的。**<br>

这个项目实现了一个协程库，参考了github上的一个开源项目。<br>
首先说下项目的技术选型：目前市面上存在的协程库主要有有栈协程和无栈协程两大类，其中有栈协程的代表有go协程和腾讯的libco，无栈协程的代表是C++20的无栈协程。这两者的主要区别在于协程切换的时候用于存储协程上下文的数据结构不一样：

- 有栈（stackful）协程：用独立的执行栈来保存协程的上下文信息，这类协程的实现类似于内核态线程的实现，不同协程间切换还是要切换对应的栈上下文，只是不用陷入内核而已。
- 无栈（stackless）协程：无栈协程的上下文都会放到公共内存中，在协程切换时使用状态机来切换，而不用切换对应的上下文（因为都已经在堆中了），因此相比有栈协程要轻量许多。

基于目前市面上成熟的商用协程库都是有栈协程的，所以我这里也是基于有栈协程去实现的协程库。<br>
其次，有栈协程还可以细分为独立栈和共享栈，它们的区别在于协程运行时使用的栈空间不一样。通过共享栈实现的协程库中的每一个协程在运行时都使用一个公共的栈空间，当协程挂起时将自己的数据从共享栈拷贝到自己的独立栈，协程运行时又将数据从独立栈拷贝到共享栈运行；使用独立栈实现的协程库中的每一个协程都有自己独立的栈空间，协程栈大小固定且互不干扰。<br>
共享栈的好处在于保存数据的时候需要多少空间开辟多少空间，可以减少内存的浪费，但会带来额外的拷贝开销。独立栈的好处在于没有内存拷贝开销，但是会带来空间浪费问题。因为栈空间在运行时不能随时扩容，为了防止栈内存不够，每个协程都要预先开一个足够的栈空间使用。当然很多协程在实际运行中也用不了这么大的空间，就必然造成内存的浪费和开辟大内存造成的性能损耗。<br>
而这里我是参考了腾讯的libco，使用的是独立栈而非共享栈。但也有不一样的地方，腾讯的libco是既实现了独立栈也实现了共享栈，只不过默认使用独立栈。因为腾讯的libco是运用在微信上的，是支持百万级高并发的。如果使用独立栈，它的大小固定为128KB，那么就需要122GB的内存，这样明显和轻量级有矛盾了。但由于二八定律的存在，大多数协程实际使用的栈空间都要比预分配的128KB要小，在这种情况下使用共享栈所占用的内存就会少很多。<br>
协程还分为对称协程和非对称协程，像go就是对称协程、libco是非对称协程。这两种协程的本质区别在于协程之间是否有明显的调用关系，go协程每个协程都是平等的，没有明显的调用关系，而非对称协程存在明显的调用者和被调用者关系。而我这里参考的是腾讯的libco，实现的是非对称协程，因为对称协程协程间可以相互切换，也就是说每个协程不仅要运行自己的入口函数代码，还要负责选出下一个合适的协程进行切换，相当于每个协程都要充当调度器的角色，这样程序设计起来会比较麻烦，并且程序的控制流也会变得复杂和难以管理。<br>
基于以上技术选型，我参考github上的开源项目编写了这个协程库。主要实现了协程库的编写，基于u_context实现了协程类、结合epoll和定时器实现了N-M协程调度器，支持I/O事件、定时器的回调，基于协程调度，对常见的系统API进行hook封装实现异步。<br>


# 协程模块

1. 什么是协程？协程和函数都可以调用，它们的区别是什么？协程为什么可以yield、resume？协程和线程有什么区别？

   协程的本质就是函数和函数运行状态的组合 。<br>

   函数是按顺序执行的代码块，从第一行开始，到返回或最后一行结束。一旦调用，函数就会完全运行，直到完成或返回结果。它只能返回一次，返回后无法恢复。常规函数通常是阻塞的，这意味着它们会保留执行流直到完成。<br>
   协程是一种特殊类型的函数，可以在某些点暂停和恢复其执行。协程可以暂停执行并将控制权交给其他协程。它们可以稍后恢复，从而允许异步操作而不会阻塞程序。协程可以暂停、产生中间结果，并在完成之前多次恢复。协程是非阻塞的，这使得它们对于 I/O 绑定操作等任务很有用，在这些任务中，等待外部资源可能会发生而不会拖延程序的其余部分。<br>

   主要区别：

   - 控制流：函数直接执行，而协程可以暂停和恢复。
   - 并发性：协程允许异步、非阻塞执行，而函数通常是阻塞的。
   - 语法：协程使用 `yield` 和 `resume` 进行暂停和恢复，而函数没有这些结构。

   
   协程能够半路yield、再重新resume的关键是协程存储了函数在yield时间点的执行状态，这个状态称为协程上下文。协程上下文包含了函数在当前执行状态下的全部CPU寄存器的值，这些寄存器值记录了函数栈帧、代码的执行位置等信息，如果将这些寄存器的值重新设置给CPU，就相当于重新恢复了函数的运行。在Linux系统里这个上下文用ucontext_t结构体来表示，通getcontext()来获取。<br>

   协程虽然被称为轻量级线程，但在单线程内，协程并不能并发执行，只能是一个协程结束或yield后，再执行另一个协程，而线程则是可以真正并发执行的。因为单线程下协程并不是并发执行，而是顺序执行的，所以不要在协程里使用线程级别的锁来做协程同步，比如pthread_mutex_t。如果一个协程在持有锁之后让出执行，那么同线程的其他任何协程一旦尝试再次持有这个锁，整个线程就锁死了，这和单线程环境下，连续两次对同一个锁进行加锁导致的死锁道理完全一样。<br>
2. 用通俗的语言介绍下什么是创建协程、协程调度、IO协程调度和定时器？

   创建协程，其实就是把一个函数包装成一个协程对象，然后再用协程的方式把这个函数跑起来。<br>   
   协程调度，其实就是创建一批的协程对象，然后再创建一个调度协程，通过调度协程把这些协程对象一个一个消化掉（协程可以在被调度时继续向调度器添加新的调度任务）。<br>
   IO协程调度，其实就是在调度协程时，如果发现这个协程在等待IO就绪，那就先让这个协程让出执行权，等对应的IO就绪后再重新恢复这个协程的运行。<br>
   定时器，就是给调度协程预设一个协程对象，等定时时间到了就恢复预设的协程对象。<br>
3. 你说了基于 u_context 实现了协程类，具体是怎么实现的？u_context的定义和操作函数都有哪些？

   ```cpp
   // 上下文结构体定义
   // 这个结构体是平台相关的，因为不同平台的寄存器不一样
   // 下面列出的是所有平台都至少会包含的4个成员
   typedef struct ucontext_t {
      // 当前上下文结束后，下一个激活的上下文对象的指针，只在当前上下文是由makecontext创建时有效
      struct ucontext_t *uc_link;
      // 当前上下文的信号屏蔽掩码
      sigset_t          uc_sigmask;
      // 当前上下文使用的栈内存空间，只在当前上下文是由makecontext创建时有效
      stack_t           uc_stack;
      // 平台相关的上下文具体内容，包含寄存器的值
      mcontext_t        uc_mcontext;
      ...
   } ucontext_t;

   // 获取当前的上下文
   int getcontext(ucontext_t *ucp);

   // 恢复ucp指向的上下文，这个函数不会返回，而是会跳转到ucp上下文对应的函数中执行，相当于变相调用了函数
   int setcontext(const ucontext_t *ucp);

   // 修改由getcontext获取到的上下文指针ucp，将其与一个函数func进行绑定，支持指定func运行时的参数，
   // 在调用makecontext之前，必须手动给ucp分配一段内存空间，存储在ucp->uc_stack中，这段内存空间将作为func函数运行时的栈空间，
   // 同时也可以指定ucp->uc_link，表示函数运行结束后恢复uc_link指向的上下文，
   // 如果不赋值uc_link，那func函数结束时必须调用setcontext或swapcontext以重新指定一个有效的上下文，否则程序就跑飞了
   // makecontext执行完后，ucp就与函数func绑定了，调用setcontext或swapcontext激活ucp时，func就会被运行
   void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);

   // 恢复ucp指向的上下文，同时将当前的上下文存储到oucp中，
   // 和setcontext一样，swapcontext也不会返回，而是会跳转到ucp上下文对应的函数中执行，相当于调用了函数
   // swapcontext是sylar非对称协程实现的关键，线程主协程和子协程用这个接口进行上下文切换
   int swapcontext(ucontext_t *oucp, const ucontext_t *ucp);
   ```

   首先需要了解 `ucontext_t` ，这是一个结构体，包含有一些常见的用于上下文切换的成员：
   
   - 下一个激活的上下文对象的指针 `struct ucontext_t *uc_link` 
   - 当前上下文使用的栈内存空间 `stack_t uc_stack`

   除此之外，ucontext_t函数族还提供了辅助上下文切换的函数，有如下几个。
   
   - 获取当前上下文的 `int getcontext(ucontext_t *ucp);`
   - 恢复当前上下文的的 `int setcontext(const ucontext_t *ucp);`
   - 把获取的上下文指针和函数进行绑定并支持传参的 `void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);`
   - 交换当前上下文的 `int swapcontext(ucontext_t *oucp, const ucontext_t *ucp);`
   
   在这里，基于ucontext_t实现协程类，具体有以下操作：
   
   - 在协程的无参构造函数中使用 `int getcontext(ucontext_t *ucp);` 来获取当前上下文，创建线程的第一个协程，也就是主协程；
   - 在协程的有参数构造函数中，通过 `void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);` 把当前上下文和传入的函数进行绑定，用于构建用户协程；
   - 同时借助 `int swapcontext(ucontext_t *oucp, const ucontext_t *ucp);` 交换当前上下文实现协程的 yield 和 resume；
   - 在重置协程时，先通过 `int getcontext(ucontext_t *ucp);` 来获取当前上下文，之后通过 `void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);` 把当前上下文和传入的函数进行绑定，实现协程重置，重复利用已结束的协程，复用其栈空间，创建新协程。
4. 对称协程和非对称协程、有栈协程和无栈协程区别是什么？

   对称协程和非对称协程本质区别在于协程之间是否有明显的调用关系。<br>
   对称协程：协程之间不存在明显的调用关系，任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移。例如go协程就是对称协程。<br>
   非对称协程：协程之间存在调用方-被调用方关系，协程出让调度权的目标只能是它的调用者。也就是子协程只能和线程主协程切换，而不能和另一个子协程切换，并且在程序结束时，一定要再切回主协程，以保证程序能正常结束。例如腾讯的libco就是非对称线程。<br>

   这两种协程各有优缺点：对称协程更灵活，非对称协程实现更简单。在对称协程中，子协程可以直接和子协程切换，也就是说每个协程不仅要运行自己的入口函数代码，还要负责选出下一个合适的协程进行切换，相当于每个协程都要充当调度器的角色，这样程序设计起来会比较麻烦，并且程序的控制流也会变得复杂和难以管理。而在非对称协程中，可以借助专门的调度器来负责调度协程，每个协程只需要运行自己的入口函数，然后结束时将运行权交回给调度器，由调度器来选出下一个要执行的协程即可。<br>

   有栈协程和无栈协程的本质区别在于协程切换的时候用于存储协程上下文的数据结构不一样：

   - 有栈（stackful）协程：用独立的执行栈来保存协程的上下文信息，这类协程的实现类似于内核态线程的实现，不同协程间切换还是要切换对应的栈上下文，只是不用陷入内核而已。典型的有栈协程有go协程和腾讯的libco。
   - 无栈（stackless）协程：无栈协程的上下文都会放到公共内存中，在协程切换时使用状态机来切换，而不用切换对应的上下文（因为都已经在堆中了），因此相比有栈协程要轻量许多。典型的无栈协程有C++20实现的无栈协程。
5. 了解有栈协程中的独立栈和共享栈吗？

   独立栈和共享栈的区别在于协程运行时使用的栈空间不一样。
   
   - 通过共享栈实现的协程库中的每一个协程在运行时都使用一个公共的栈空间，当协程挂起时将自己的数据从共享栈拷贝到自己的独立栈，协程运行时又将数据从独立栈拷贝到共享栈运行。
   - 使用独立栈实现的协程库中的每一个协程都有自己独立的栈空间，协程栈大小固定且互不干扰。
   
   两种协程的优缺点如下：

   - 共享栈的好处在于保存数据的时候需要多少空间开辟多少空间，可以减少内存的浪费，但会带来额外的拷贝开销。
   - 独立栈的好处在于没有内存拷贝开销，但是会带来空间浪费问题。因为栈空间在运行时不能随时扩容，为了防止栈内存不够，每个协程都要预先开一个足够的栈空间使用。当然很多协程在实际运行中也用不了这么大的空间，就必然造成内存的浪费和开辟大内存造成的性能损耗。
6. 协程的优缺点？

   优点：

   - 提高资源利用率，提高程序并发性能。协程允许开发者编写异步代码，实现非阻塞的并发操作，通过在适当的时候挂起和恢复协程，可以有效地管理多个任务的执行，提高程序的并发性能。与线程相比，协程是轻量级的，它们的创建和上下文切换开销较小，可以同时执行大量的协程，而不会导致系统负载过重，可以在单线程下实现异步，使程序不存在阻塞阶段，充分利用cpu资源。
   - 简化异步编程逻辑。使用协程可以简化并发编程的复杂性，通过使用适当的协程库或语言特性，可以避免显式的线程同步、锁和互斥量等并发编程的常见问题，用同步的思想就可以编写成异步的程序。

   缺点：

   - 最明显的缺点是无法利用多核资源。线程才是系统调度的基本单位，单线程下的多协程本质上还是串行执行的，只能用到单核计算资源，所以协程往往要与多线程、多进程一起使用。
7. 协程切换的时候，运行栈保存和切换的步骤是如何实现的？

   首先u_context函数族里面有一个变量叫协程上下文，它里面包含了协程运行时的上下文指针、栈指针和栈的初始化大小。在每一个协程创建的时候，都会先初始化这三个变量，以方便保存运行栈的信息。<br>
   接着在协程切换的时候，会调用 `int swapcontext(ucontext_t *oucp, const ucontext_t *ucp);` 实现两个协程的上下文切换，其中传入的两个参数就是两个协程的上下文指针。也就是说运行栈的切换是通过传入两个上下文指针到给定的函数里面去实现的，是 u_context 函数族自己已经定义好的特性。<br>

# 协程调度模块

1. 什么是协程调度？

   当你有很多协程时，如何把这些协程都消耗掉，这就是协程调度。
2. 为什么需要协程调度？

   如果没有协程调度，对于每个协程，都需要用户手动调用协程的resume方法将协程运行起来，然后等协程运行结束并返回，再运行下一个协程。这种运行协程的方式其实是用户自己在挑选协程执行，相当于用户在充当调度器，显然不够灵活。而且在这种情况下，一个子协程不能运行另一个子协程。当实现了调度器后，子协程可以通过向调度器添加调度任务的方式运行另一个子协程。
3. 调度任务的形式有哪些？

   协程和函数都可以，因为函数也是可执行的对象。
4. 为什么要把调度线程所在线程加入到调度中？

   在实现相同调度能力的情况下(指能够同时调度的协程数量)，线程数越小，线程切换的开销也就越小，效率就更高一些，所以，调度器所在的线程，也应该支持用来执行调度任务。
5. 调度器的设计是怎么样的？

   - 首先，调度器调度的是协程，所以需要有一个任务队列保存协程任务。
   - 其次，一个线程里面某一时刻只能有一个协程运行，所以为了并行运行提升系统利用率，会有一个调度线程池用于实现多线程。
   - 但是，仅仅往任务队列里面添加任务就希望调度线程会自动执行任务是不现实的，因为调度线程并不知道有新任务进来。所以需要有一个消息通信机制通知线程当前有任务可以调度。
   
   综上，调度器内部维护一个任务队列和一个调度线程池，并实现了消息通信机制。开始调度后，线程池从任务队列里按顺序取任务执行。当全部任务都执行完了，线程池停止调度，等新的任务进来。添加新任务后，通知线程池有新的任务进来了，线程池重新开始运行调度。停止调度时，各调度线程退出，调度器停止工作。
6. 如何添加调度任务？

   有两种方式：
   
   - 第一种是通过schedule方法，这个方法支持传入协程或函数，并且支持一个线程号参数，表示是否将这个协程或函数绑定到一个具体的线程上执行。如果任务队列为空，那么在添加任务之后，要调用一次tickle方法以通知各调度线程的调度协程有新任务来了。
   - 第二种是执行调度任务时，还可以通过调度器的GetThis()方法获取到当前调度器，再通过schedule方法继续添加新的任务，这就变相实现了在子协程中创建并运行新的子协程的功能。
7. 最难的点：当调度线程也参与调度时调度协程和主线程切换的情况，即简历中的支持主线程(创建调度器的线程)参与调度。

   其实这个问题的本质在于如何存储协程调用链。<br>
   在腾讯的libco中，使用一个栈来保存协程之间的调用关系，我们可以把它称为调用栈。具体过程如下：每当启动（resume）一个协程时，就将它的协程控制块 stCoRoutine_t 结构指针保存在调用栈的“栈顶”，然后“栈指针” iCallStackSize 加 1，最后切换上下文 到待启动协程运行。当协程要让出（yield）CPU 时，就将它的 stCoRoutine_t从调用栈弹出，“栈指针” iCallStackSize 减 1，然后切换上下文到当前栈顶的协程（原来被挂起的调用者）恢复执行。<br>
   在我的项目中，我并没有参考腾讯的做法额外实现一个调用栈，因为我觉得会浪费空间、增加实现复杂度。所以我这里使用了两个线程局部变量，一个用于存储主协程的上下文，一个用于存储当前协程的上下文，采用 `swapcontext()` 函数进行切换。<br>
   这种情况在主协程没有参与调度的情况下是可行的，因为这个时候主协程会在线程池中取一个线程作为调度线程，调度线程就可以从任务队列里面取任务执行，main函数与调度无关。它只需要负责向调度器添加任务，在所有任务都执行完后停止调度就可以了。<br>
   **主线程和调度线程如何切换的？通过什么方式告诉主线程所有任务已经调度完成？**<br>
   但是额外使用一个调度线程作为调度器，意味着少了一个协程去执行调度任务，所以我想的是直接在主线程里面实现调度器，这样就可以提高处理任务的线程数目。在这种情况下，主线程里面会有三种协程运行：

   - main函数对应的主协程
   - 调度协程
   - 待调度的任务协程

   这三个协程的运行顺序是这样的：

   - main函数主协程运行，创建调度器
   - 仍然是main函数主协程运行，向调度器添加一些调度任务
   - 开始协程调度，main函数主协程让出执行权，切换到调度协程，调度协程从任务队列里按顺序执行所有的任务
   - 每次执行一个任务，调度协程都要让出执行权，再切到该任务的协程里去执行，任务执行结束后，还要再切回调度协程，继续下一个任务的调度
   - 所有任务都执行完后，调度协程还要让出执行权并切回main函数主协程，以保证程序能顺利结束。

   可以总结为：main函数先攒下一波协程，然后切到调度协程里去执行，等把这些协程都消耗完后，再从调度协程切回来。但是在非对称协程里，子协程只能和主协程切换，子协程之间不能发生切换。而在这种情况中，main函数对应协程是主协程，调度协程和任务协程都是子协程。也就是说，调度协程不能直接和任务协程切换，否则会因为main函数的上下文丢失而使得main函数协程跑飞。<br>
   其实，子协程和子协程切换导致线程主协程跑飞的关键原因在于，每个线程只有两个线程局部变量用于保存当前的协程上下文信息。也就是说线程任何时候都最多只能知道两个协程的上下文，其中一个是当前正在运行协程的上下文，另一个是线程主协程的上下文，如果子协程和子协程切换，那这两个上下文都会变成子协程的上下文，线程主协程的上下文丢失了，程序也就跑飞了。如果不改变这种情况，就只能线程主协程去充当调度协程，这就相当于又回到了让用户充当调度器的情况。<br>
   所以这里，我们需要给每个线程增加一个线程局部变量用于保存调度协程的上下文。这样，每个线程可以同时保存三个协程的上下文，一个是当前正在执行的协程上下文，另一个是线程主协程的上下文，最后一个是调度协程的上下文。<br>
   而改进后，调度器停止时，应该让调度线程的调度协程也运行一次，让调度协程完成调度工作后才可以完全退出。<br>
8. idle如何处理？

   当调度协程已经把任务队列中的任务调度完毕，没有任务可处理时，会进入idle状态，这个时候可以使用tickle处理，具体看下一章。

# I/O协程调度模块

首先，这个模块由两部分组成：

- 基于epoll实现IO事件的注册、添加、删除、取消等功能。
- 将epoll与协程调度融合，实现tickle和idle。

搞清楚以下事情：

- 如何实现IO事件的操作？
- 如何实现消息通信机制：什么时候往管道写、什么时候读？
- 如何处理idle问题？

会被问到的问题：

1. 为什么需要IO协程调度？

   IO事件调度功能对服务器开发至关重要，因为服务器通常需要处理大量来自客户端的socket fd，使用IO事件调度可以将开发者从判断socket fd是否可读或可写的工作中解放出来，使得程序员只需要关心socket fd的IO操作。
2. 这个模块是怎么设计的？

   对于IO调度，因为事件来源于epoll_wait返回，所以需要记录事件的描述符，同时还需要记录事件的类型以及这个事情发生后的回调函数。所以这里设置了一个三元组信息，分别是描述符-事件类型（可读或可写）-回调函数。其中描述符和事件类型用于epoll_wait，回调函数用于协程调度。这个三元组信息在源码上通过FdContext结构体来存储，在执行epoll_wait时通过epoll_event的私有数据指针data.ptr来保存FdContext结构体信息。<br>
   接着讲下基于epoll实现了两个模块，可以参考下面去说吧。<br>
3. FdContext是如何寻址的？

   直接使用fd的值作为FdContext数组的下标，这样可以快速找到一个fd对应的FdContext。由于关闭的fd会被重复利用，所以这里也不用担心FdContext数组膨胀太快，或是利用率低的问题。
4. 如何实现IO事件的操作？
   
   IO事件的操作包含了IO事件的注册、删除、取消。<br>

   IO事件的注册：需要往函数里面传入需要监听的事件的文件描述符、事件类型和回调函数，之后根据fd去上下文结构体里寻找对应的事件。因为fd是复用的，如果传入的fd是复用过的，那么使用epoll_ctl加入IO多路复用的时候，使用的是EPOLL_CTL_MOD，否则使用EPOLL_CTL_ADD表示新注册一个事件。之后还要更新上下文结构体FdContext里面的事件类型、回调函数。<br>
   IO事件的删除：需要往函数里面传入需要监听的事件的文件描述符、事件类型。也是根据传入的fd去寻找对应的事件，之后使用位操作清除指定事件。若剩余事件集合为空，那么使用EPOLL_CTL_DEL直接把所有事件删除，否则使用EPOLL_CTL_MOD把剩余事件通过epoll_ctl加入到fd需要继续监听的事件集合里面。<br>
   IO事件的取消：和IO事件的删除基本一样，只不过需要在删除前出发一次事件。<br>

   在这里通过定义一个IOManager类来实现管道可读事件的注册，以实现消息通知机制从而实现IO任务调度。在初始化时，IOManager 会创建一个 epoll 文件描述符，并设置一个 pipe 用于唤醒机制。之后通过epoll_ctl，监听管道上的可读事件，并将管道的读描述符加入epoll多路复用，如果管道可读，idle中的epoll_wait会返回。这样当没有 IO 事件发生时，IOManager 可以阻塞在 epoll_wait 调用上，等待事件的发生。<br>
5. 如何实现tickle以实现消息通信机制？什么时候往管道里面读写内容？

   其实就是往管道读端里面写数据，这样epoll_wait里面注册的pipe读事件就会触发，进一步会检测到目前有哪些IO事件是已经完成注册并且是等待执行的。<br>
   tickle在以下情况会被调用：

   - 插入新的定时器；
   - 定时器到时；
   - 注册新的IO事件时；
   - 一个任务处理完后，任务队列里面不为空时，也会调用tickle；
   - 调度协程主动停止调度时。
6. 如何处理idle问题？

   首先需要明确的一件事，当调度协程无调度任务时，调度协程会阻塞在在等待IO事件上，阻塞退出的时机是epoll_wait返回，对应的操作是tickle往管道里面写数据告诉协程有新任务到来、或者是定时器注册的定时事件超时返回。<br>
   如果是tickle往管道里面写数据导致epoll_wait返回，这个时候需要遍历所有发生的事件，根据epoll_event的私有指针找到对应的FdContext三元组，执行回调函数进行事件处理。如果是定时器时间超时，会根据当前的绝对时间把已超时的所有定时器收集起来，执行它们的回调函数。<br>
   由于epoll_wait的返回并不一定是超时引起的，也有可能是IO事件唤醒的，所以在epoll_wait返回后不能想当然地假设定时器已经超时了，而是要再判断一下定时器有没有超时，这时绝对时间的好处就体现出来了，通过比较当前的绝对时间和定时器的绝对超时时间，就可以确定一个定时器到底有没有超时。<br>

# 定时器模块

定时器的组成其实就是两个部分，一个是存放定时事件的容器，另一个是定时通知机制。<br>
在这里，存在定时器的容器选择的是最小堆。但并没有自定义一个堆，而是使用 `std::set` 实现了一个最小堆，具体 `std::set<Timer::ptr, Timer::Comparator> m_timers;`，同时通过往set的参数里面传递一个自定义的比较函数 `Comparator()` 为最小堆排序，这个函数需要传入两个要比较的定时器作为参数。<br>
至于为什么选择最小堆而不是选择其他的容器，例如升序链表。出于以下考虑：

- **升序链表**将计时器组织在一个排序列表中，其中每个节点代表一个计时器，计时器按其到期时间排序。列表的头部始终保存下一个到期的计时器。
- 优点在于易于实现和能够快速检索最近的计时器，缺点是插入成本高(插入新计时器需要扫描列表以找到正确位置，最坏情况下的复杂度为 O(n))和可拓展性差(随着计时器数量的增加，插入的开销会显著增加。)。
- 所以它适合定时器数量少和紧密聚集的场景。
<br>

- **最小堆**将计时器组织为二叉堆，其中最早到期的计时器始终位于根部。插入和删除保持堆属性。
- 优点在于高效提取、平衡插入和删除(插入和删除操作的时间复杂度均为 O(log n))；缺点在于实现起来可能比链表复杂。
- 所以在适用于具有大量定时器，且定时器随机分布的场景。

综合上面的优缺点，我选择了最小堆作为保存定时事件的容器。<br>

而在时间的选择上，我采用的是绝对时间而非相对时间，因为它相比相对时间具有可预测性和重启之后的一致性。但传入的是相对时间，但会在Timer初始化或者refresh Timer的时候把相对时间转化为绝对时间，通过使用 `clock_gettime` 和 `CLOCK_MONOTONIC_RAW` 获取当前时间，再把当前时间和传入的相对时间相加，获取超时的绝对时间。<br>

对于定时器的操作，这里分为两个模块，分别是定时器的操作和定时器管理器的操作：

- 其中定时器的操作包括取消定时器、刷新设置定时器的执行时间和重置定时器时间。
- 定时器管理器操作包括添加定时器、到最近一个定时器执行的时间间隔、获取需要执行的定时器的回调函数列表和判断是否有定时器。

而定时通知机制使用的是epoll_wait，往里面传入所有定时器最小的超时时间，也就是堆顶的定时器的时间，超时就触发。<br>

所以定时器执行定时任务过程如下：<br>
IO协程调度器的idle协程会在调度器空闲时阻塞在epoll_wait上，等待IO事件发生。加入定时器功能前，epoll_wait具有固定的超时时间，这个值是5秒钟。加入定时器功能后，epoll_wait的超时时间改用当前定时器的最小超时时间来代替。epoll_wait返回后，根据当前的绝对时间把已超时的所有定时器收集起来，执行它们的回调函数。<br>
由于epoll_wait的返回并不一定是超时引起的，也有可能是IO事件唤醒的，所以在epoll_wait返回后不能想当然地假设定时器已经超时了，而是要再判断一下定时器有没有超时，这时绝对时间的好处就体现出来了，通过比较当前的绝对时间和定时器的绝对超时时间，就可以确定一个定时器到底有没有超时。<br>


# hook模块

1. 什么是hook？
   
   hook实际上就是对系统调用API进行一次封装，将其封装成一个与原始的系统调用API同名的接口，应用在调用这个接口时，会先执行封装中的操作，再执行原始的系统调用API。
2. 为什么要使用hook？
   
   把博客上的 **[例子](https://www.midlane.top/wiki/pages/viewpage.action?pageId=16417219#hook%E6%A8%A1%E5%9D%97-hook%E5%8A%9F%E8%83%BD)** 背背。
3. 接下去可以介绍下静态hook和动态hook，并介绍两种动态hook，说明自己这里用的是侵入式hook。同时可以说下静态链接和动态链接的区别。
4. `dlsym` `RTLD_NEXT` 和符号名称这一点，具体看 **[博客](https://www.midlane.top/wiki/pages/viewpage.action?pageId=16417219#hook%E6%A8%A1%E5%9D%97-hook%E5%AE%9E%E7%8E%B0)** 。
5. hook模块设计
   
   设置了一个类来记录所有分配过的fd的上下文，记录了当前fd是否为socket、是否用户主动设置了非阻塞、是否关闭等的信息。同时重写了sleep系列延迟接口和socket IO系列接口。<br>
   sleep系列接口的hook思路完全一样，都是根据当前超时时间设置定时器，之后yield，这样就可以去执行其他协程了。<br>
   而socket系列接口的思路也差不多，都是需要先判断传进来的传进来的接口是否为套接字或用户显示设置了非阻塞，如果是的话就直接调用系统的API接口并返回。否则添加一个定时器并执行yield，在定时时间到后通过定时器的取消函数注销定时器并触发事件。但是事件有可能在定时时间之前就可读或可写了，这个时候就需要判断：如果先超时，那么就按上面说的处理；如果事件在超时时间前在epoll_wait返回了，那么直接取消定时器并执行时间。
