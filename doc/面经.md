# 协程模块

1. 画一下项目的框架图。
   
   
2. 什么是协程？协程和函数都可以调用，它们的区别是什么？协程为什么可以yield、resume？协程和线程有什么区别？
   
   协程的本质就是函数和函数运行状态的组合 。
   协程和函数的不同之处是，函数一旦被调用，只能从头开始执行，直到函数执行结束退出，而协程则可以执行到一半就退出（称为yield），但此时协程并未真正结束，只是暂时让出CPU执行权，在后面适当的时机协程可以重新恢复运行（称为resume），在这段时间里其他的协程可以获得CPU并运行，所以协程也称为轻量级线程。
   协程能够半路yield、再重新resume的关键是协程存储了函数在yield时间点的执行状态，这个状态称为协程上下文。协程上下文包含了函数在当前执行状态下的全部CPU寄存器的值，这些寄存器值记录了函数栈帧、代码的执行位置等信息，如果将这些寄存器的值重新设置给CPU，就相当于重新恢复了函数的运行。在Linux系统里这个上下文用ucontext_t结构体来表示，通getcontext()来获取。
   协程虽然被称为轻量级线程，但在单线程内，协程并不能并发执行，只能是一个协程结束或yield后，再执行另一个协程，而线程则是可以真正并发执行的。因为单线程下协程并不是并发执行，而是顺序执行的，所以不要在协程里使用线程级别的锁来做协程同步，比如pthread_mutex_t。如果一个协程在持有锁之后让出执行，那么同线程的其他任何协程一旦尝试再次持有这个锁，整个线程就锁死了，这和单线程环境下，连续两次对同一个锁进行加锁导致的死锁道理完全一样。

3. 用通俗的语言介绍下什么是创建协程、协程调度、IO协程调度和定时器？
   
   所谓创建协程，其实就是把一个函数包装成一个协程对象，然后再用协程的方式把这个函数跑起来；所谓协程调度，其实就是创建一批的协程对象，然后再创建一个调度协程，通过调度协程把这些协程对象一个一个消化掉（协程可以在被调度时继续向调度器添加新的调度任务）；所谓IO协程调度，其实就是在调度协程时，如果发现这个协程在等待IO就绪，那就先让这个协程让出执行权，等对应的IO就绪后再重新恢复这个协程的运行；所谓定时器，就是给调度协程预设一个协程对象，等定时时间到了就恢复预设的协程对象。

4. 你说了基于 u_context 实现了协程类，具体是怎么实现的？u_context的定义和操作函数都有哪些？

   ```cpp
   // 上下文结构体定义
   // 这个结构体是平台相关的，因为不同平台的寄存器不一样
   // 下面列出的是所有平台都至少会包含的4个成员
   typedef struct ucontext_t {
      // 当前上下文结束后，下一个激活的上下文对象的指针，只在当前上下文是由makecontext创建时有效
      struct ucontext_t *uc_link;
      // 当前上下文的信号屏蔽掩码
      sigset_t          uc_sigmask;
      // 当前上下文使用的栈内存空间，只在当前上下文是由makecontext创建时有效
      stack_t           uc_stack;
      // 平台相关的上下文具体内容，包含寄存器的值
      mcontext_t        uc_mcontext;
      ...
   } ucontext_t;

   // 获取当前的上下文
   int getcontext(ucontext_t *ucp);

   // 恢复ucp指向的上下文，这个函数不会返回，而是会跳转到ucp上下文对应的函数中执行，相当于变相调用了函数
   int setcontext(const ucontext_t *ucp);

   // 修改由getcontext获取到的上下文指针ucp，将其与一个函数func进行绑定，支持指定func运行时的参数，
   // 在调用makecontext之前，必须手动给ucp分配一段内存空间，存储在ucp->uc_stack中，这段内存空间将作为func函数运行时的栈空间，
   // 同时也可以指定ucp->uc_link，表示函数运行结束后恢复uc_link指向的上下文，
   // 如果不赋值uc_link，那func函数结束时必须调用setcontext或swapcontext以重新指定一个有效的上下文，否则程序就跑飞了
   // makecontext执行完后，ucp就与函数func绑定了，调用setcontext或swapcontext激活ucp时，func就会被运行
   void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);

   // 恢复ucp指向的上下文，同时将当前的上下文存储到oucp中，
   // 和setcontext一样，swapcontext也不会返回，而是会跳转到ucp上下文对应的函数中执行，相当于调用了函数
   // swapcontext是sylar非对称协程实现的关键，线程主协程和子协程用这个接口进行上下文切换
   int swapcontext(ucontext_t *oucp, const ucontext_t *ucp);
   ```

5. 对称协程和非对称协程、有栈协程和无栈协程区别是什么？
   
   对称协程，协程可以不受限制地将控制权交给任何其他协程。任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移。
   非对称协程，是指协程之间存在类似堆栈的调用方-被调用方关系。协程出让调度权的目标只能是它的调用者。也就是子协程只能和线程主协程切换，而不能和另一个子协程切换，并且在程序结束时，一定要再切回主协程，以保证程序能正常结束。
   对称协程更灵活，非对称协程实现更简单。在对称协程中，⼦协程可以直接和⼦协程切换，也就是说每个协程不仅要运行自己的入口函数代码，还要负责选出下一个合适的协程进行切换，相当于每个协程都要充当调度器的角色，这样程序设计起来会比较麻烦，并且程序的控制流也会变得复杂和难以管理。而在非对称协程中，可以借助专门的调度器来负责调度协程，每个协程只需要运行自己的入口函数，然后结束时将运行权交回给调度器，由调度器来选出下一个要执行的协程即可。
   有栈协程和无栈协程指的是协程切换的时候用于存储协程上下文的数据结构不一样。
   有栈协程：用独立的执行栈来保存协程的上下⽂信息。当协程被挂起时，栈协程会保存当前执行状态（例如函数调用栈、局部变量等），并将控制权交还给调度器。当协程被恢复时，栈协程会将之前保存的执行状态恢复，从上次挂起的地方继续执行。类似于内核态线程的实现，不同协程间切换还是要切换对应的栈上下⽂，只是不用陷⼊内核
   而已。
   无栈协程：它不需要独立的执行栈来保存协程的上下⽂信息，协程的上下⽂都放到公共内存中，当协程被挂起时，无栈协程会将协程的状态保存在堆上的数据结构中，并将控制权交还给调度器。当协程被恢复时，无栈协程会将之前保存的状态从堆中取出，并从上次挂起的地方继续执行。协程切换时，使用状态机来切换，就不用切换对应的上
   下⽂了，因为都在堆⾥的。比有栈协程都要轻量许多。
   
6. 了解有栈协程中的独立栈和共享栈吗？
   
   共享栈本质就是所有的协程在运行的时候都使用同一个栈空间，每次协程切换时要把⾃身用的共享栈空间拷⻉。对协程调用 yield 的时候，该协程栈内容暂时保存起来，保存的时候需要用到多少内存就开辟多少，这样就减少了内存的浪费， resume 该协程的时候，协程之前保存的栈内容，会被重新拷⻉到运行时栈中。
   独立栈，也就是每个协程的栈空间都是独立的，固定⼤⼩。好处是协程切换的时候，内存不用拷⻉来拷⻉去。坏处则是内存空间浪费。因为栈空间在运行时不能随时扩容，否则如果有指针操作执行了栈内存，扩容后将导致指针失效。为了防⽌栈内存不够，每个协程都要预先开一个⾜够的栈空间使用。当然很多协程在实际运行中也用不了这么
   ⼤的空间，就必然造成内存的浪费和开辟⼤内存造成的性能损耗。
   独立栈相对简单，但废内存，容易栈溢出。
   共享栈使用公共资源，公共资源内存空间比较⼤，相对安全，节省内存空间，但是协程频繁切换需要进行内存拷⻉，废 CPU。
   项目里的栈是独立栈，因为实现起来比较简单。

7. 协程的优缺点？
    
   优点：
    1. 提高资源利用率，提高程序并发性能。协程允许开发者编写异步代码，实现非阻塞的并发操作，通过在适当的时候挂起和恢复协程，可以有效地管理多个任务的执行，提高程序的并发性能。与线程相比，协程是轻量级的，它们的创建和上下⽂切换开销较⼩，可以同时执行⼤量的协程，而不会导致系统负载过重，可以在单线程下实现异步，使程序不存在阻塞阶段，充分利用cpu资源。
    2. 简化异步编程逻辑。使用协程可以简化并发编程的复杂性，通过使用适当的协程库或语⾔特性，可以避免显式的线程同步、锁和互斥量等并发编程的常⻅问题，用同步的思想就可以编写成异步的程序。
   
   缺点：
    1. 最明显的缺点是无法利用多核资源。线程才是系统调度的基本单位，单线程下的多协程本质上还是串行执行的，只能用到单核计算资源，所以协程往往要与多线程、多进程一起使用。


# 协程调度模块

1. 什么是协程调度？
   当你有很多协程时，如何把这些协程都消耗掉，这就是协程调度。
2. 为什么需要协程调度？
   如果没有协程调度，对于每个协程，都需要用户手动调用协程的resume方法将协程运行起来，然后等协程运行结束并返回，再运行下一个协程。这种运行协程的方式其实是用户自己在挑选协程执行，相当于用户在充当调度器，显然不够灵活。而且在这种情况下，一个子协程不能运行另一个子协程。当实现了调度器后，子协程可以通过向调度器添加调度任务的方式运行另一个子协程。
3. 调度任务的形式有哪些？
   协程和函数都可以，因为函数也是可执行的对象。
4. 为什么要把调度线程所在线程加入到调度中？
   在实现相同调度能力的情况下(指能够同时调度的协程数量)，线程数越小，线程切换的开销也就越小，效率就更高一些，所以，调度器所在的线程，也应该支持用来执行调度任务。
5. 简述调度器的工作过程。
   运行过程：可以简单地认为，调度器创建后，内部首先会创建一个调度线程池，调度开始后，所有调度线程按顺序从任务队列里取任务执行，调度线程数越多，能够同时调度的任务也就越多，当所有任务都调度完后，调度线程就停下来等新的任务进来。
   添加调度任务的本质就是往调度器的任务队列里塞任务，但是，只添加调度任务是不够的，还应该有一种方式用于通知调度线程有新的任务加进来了，因为调度线程并不一定知道有新任务进来了。
   调度器应该支持停止调度的功能，以便回收调度线程的资源，只有当所有的调度线程都结束后，调度器才算真正停止。
6. 调度器的设计是怎么样的？
   调度器内部维护一个任务队列和一个调度线程池。开始调度后，线程池从任务队列里按顺序取任务执行。当全部任务都执行完了，线程池停止调度，等新的任务进来。添加新任务后，通知线程池有新的任务进来了，线程池重新开始运行调度。停止调度时，各调度线程退出，调度器停止工作。
7. idle如何处理？

最难的点：当调度线程也参与调度时调度协程和主线程切换的情况，即简历中的⽀持主线程(创建调度器的线程)参与调度。<br>
解决方案的关键点在于：<br>
子协程和子协程切换导致线程主协程跑飞的关键原因在于，每个线程只有两个线程局部变量用于保存当前的协程上下文信息。也就是说线程任何时候都最多只能知道两个协程的上下文，其中一个是当前正在运行协程的上下文，另一个是线程主协程的上下文，如果子协程和子协程切换，那这两个上下文都会变成子协程的上下文，线程主协程的上下文丢失了，程序也就跑飞了。如果不改变这种局部，就只能线程主协程去充当调度协程，这就相当于又回到了让用户充当调度器的情况。<br>
那么，如何改变这种情况呢？其实非常简单，只需要给每个线程增加一个线程局部变量用于保存调度协程的上下文就可以了，这样，每个线程可以同时保存三个协程的上下文，一个是当前正在执行的协程上下文，另一个是线程主协程的上下文，最后一个是调度协程的上下文。有了这三个上下文，协程就可以根据自己的身份来选择和每次和哪个协程进行交换。<br>
但是面试的时候可不能说这么简单，毕竟是难点，可以 **[参考](https://www.midlane.top/wiki/pages/viewpage.action?pageId=10060963#id-%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9D%97-%E8%B0%83%E5%BA%A6%E5%8D%8F%E7%A8%8B%E5%88%87%E6%8D%A2%E9%97%AE%E9%A2%98)** ，理解后形成自己的说辞。<br>