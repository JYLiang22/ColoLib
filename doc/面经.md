# 协程模块

1. 画一下项目的框架图。
   
   
2. 什么是协程？协程和函数都可以调用，它们的区别是什么？协程为什么可以yield、resume？协程和线程有什么区别？
   
   协程的本质就是函数和函数运行状态的组合 。
   协程和函数的不同之处是，函数一旦被调用，只能从头开始执行，直到函数执行结束退出，而协程则可以执行到一半就退出（称为yield），但此时协程并未真正结束，只是暂时让出CPU执行权，在后面适当的时机协程可以重新恢复运行（称为resume），在这段时间里其他的协程可以获得CPU并运行，所以协程也称为轻量级线程。
   协程能够半路yield、再重新resume的关键是协程存储了函数在yield时间点的执行状态，这个状态称为协程上下文。协程上下文包含了函数在当前执行状态下的全部CPU寄存器的值，这些寄存器值记录了函数栈帧、代码的执行位置等信息，如果将这些寄存器的值重新设置给CPU，就相当于重新恢复了函数的运行。在Linux系统里这个上下文用ucontext_t结构体来表示，通getcontext()来获取。
   协程虽然被称为轻量级线程，但在单线程内，协程并不能并发执行，只能是一个协程结束或yield后，再执行另一个协程，而线程则是可以真正并发执行的。因为单线程下协程并不是并发执行，而是顺序执行的，所以不要在协程里使用线程级别的锁来做协程同步，比如pthread_mutex_t。如果一个协程在持有锁之后让出执行，那么同线程的其他任何协程一旦尝试再次持有这个锁，整个线程就锁死了，这和单线程环境下，连续两次对同一个锁进行加锁导致的死锁道理完全一样。

3. 用通俗的语言介绍下什么是创建协程、协程调度、IO协程调度和定时器？
   
   所谓创建协程，其实就是把一个函数包装成一个协程对象，然后再用协程的方式把这个函数跑起来；所谓协程调度，其实就是创建一批的协程对象，然后再创建一个调度协程，通过调度协程把这些协程对象一个一个消化掉（协程可以在被调度时继续向调度器添加新的调度任务）；所谓IO协程调度，其实就是在调度协程时，如果发现这个协程在等待IO就绪，那就先让这个协程让出执行权，等对应的IO就绪后再重新恢复这个协程的运行；所谓定时器，就是给调度协程预设一个协程对象，等定时时间到了就恢复预设的协程对象。

4. 你说了基于 u_context 实现了协程类，具体是怎么实现的？u_context的定义和操作函数都有哪些？

   ```cpp
   // 上下文结构体定义
   // 这个结构体是平台相关的，因为不同平台的寄存器不一样
   // 下面列出的是所有平台都至少会包含的4个成员
   typedef struct ucontext_t {
      // 当前上下文结束后，下一个激活的上下文对象的指针，只在当前上下文是由makecontext创建时有效
      struct ucontext_t *uc_link;
      // 当前上下文的信号屏蔽掩码
      sigset_t          uc_sigmask;
      // 当前上下文使用的栈内存空间，只在当前上下文是由makecontext创建时有效
      stack_t           uc_stack;
      // 平台相关的上下文具体内容，包含寄存器的值
      mcontext_t        uc_mcontext;
      ...
   } ucontext_t;

   // 获取当前的上下文
   int getcontext(ucontext_t *ucp);

   // 恢复ucp指向的上下文，这个函数不会返回，而是会跳转到ucp上下文对应的函数中执行，相当于变相调用了函数
   int setcontext(const ucontext_t *ucp);

   // 修改由getcontext获取到的上下文指针ucp，将其与一个函数func进行绑定，支持指定func运行时的参数，
   // 在调用makecontext之前，必须手动给ucp分配一段内存空间，存储在ucp->uc_stack中，这段内存空间将作为func函数运行时的栈空间，
   // 同时也可以指定ucp->uc_link，表示函数运行结束后恢复uc_link指向的上下文，
   // 如果不赋值uc_link，那func函数结束时必须调用setcontext或swapcontext以重新指定一个有效的上下文，否则程序就跑飞了
   // makecontext执行完后，ucp就与函数func绑定了，调用setcontext或swapcontext激活ucp时，func就会被运行
   void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);

   // 恢复ucp指向的上下文，同时将当前的上下文存储到oucp中，
   // 和setcontext一样，swapcontext也不会返回，而是会跳转到ucp上下文对应的函数中执行，相当于调用了函数
   // swapcontext是sylar非对称协程实现的关键，线程主协程和子协程用这个接口进行上下文切换
   int swapcontext(ucontext_t *oucp, const ucontext_t *ucp);
   ```

5. 对称协程和非对称协程、有栈协程和无栈协程区别是什么？
   
   对称协程，协程可以不受限制地将控制权交给任何其他协程。任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移。
   非对称协程，是指协程之间存在类似堆栈的调用方-被调用方关系。协程出让调度权的目标只能是它的调用者。也就是子协程只能和线程主协程切换，而不能和另一个子协程切换，并且在程序结束时，一定要再切回主协程，以保证程序能正常结束。
   对称协程更灵活，非对称协程实现更简单。在对称协程中，⼦协程可以直接和⼦协程切换，也就是说每个协程不仅要运行自己的入口函数代码，还要负责选出下一个合适的协程进行切换，相当于每个协程都要充当调度器的角色，这样程序设计起来会比较麻烦，并且程序的控制流也会变得复杂和难以管理。而在非对称协程中，可以借助专门的调度器来负责调度协程，每个协程只需要运行自己的入口函数，然后结束时将运行权交回给调度器，由调度器来选出下一个要执行的协程即可。
   有栈协程和无栈协程指的是协程切换的时候用于存储协程上下文的数据结构不一样。
   有栈协程：用独立的执行栈来保存协程的上下⽂信息。当协程被挂起时，栈协程会保存当前执行状态（例如函数调用栈、局部变量等），并将控制权交还给调度器。当协程被恢复时，栈协程会将之前保存的执行状态恢复，从上次挂起的地方继续执行。类似于内核态线程的实现，不同协程间切换还是要切换对应的栈上下⽂，只是不用陷⼊内核
   而已。
   无栈协程：它不需要独立的执行栈来保存协程的上下⽂信息，协程的上下⽂都放到公共内存中，当协程被挂起时，无栈协程会将协程的状态保存在堆上的数据结构中，并将控制权交还给调度器。当协程被恢复时，无栈协程会将之前保存的状态从堆中取出，并从上次挂起的地方继续执行。协程切换时，使用状态机来切换，就不用切换对应的上
   下⽂了，因为都在堆⾥的。比有栈协程都要轻量许多。
   
6. 了解有栈协程中的独立栈和共享栈吗？
   
   共享栈本质就是所有的协程在运行的时候都使用同一个栈空间，每次协程切换时要把⾃身用的共享栈空间拷⻉。对协程调用 yield 的时候，该协程栈内容暂时保存起来，保存的时候需要用到多少内存就开辟多少，这样就减少了内存的浪费， resume 该协程的时候，协程之前保存的栈内容，会被重新拷⻉到运行时栈中。
   独立栈，也就是每个协程的栈空间都是独立的，固定⼤⼩。好处是协程切换的时候，内存不用拷⻉来拷⻉去。坏处则是内存空间浪费。因为栈空间在运行时不能随时扩容，否则如果有指针操作执行了栈内存，扩容后将导致指针失效。为了防⽌栈内存不够，每个协程都要预先开一个⾜够的栈空间使用。当然很多协程在实际运行中也用不了这么
   ⼤的空间，就必然造成内存的浪费和开辟⼤内存造成的性能损耗。
   独立栈相对简单，但废内存，容易栈溢出。
   共享栈使用公共资源，公共资源内存空间比较⼤，相对安全，节省内存空间，但是协程频繁切换需要进行内存拷⻉，废 CPU。
   项目里的栈是独立栈，因为实现起来比较简单。

7. 协程的优缺点？
    
    优点：
    1. 提高资源利用率，提高程序并发性能。协程允许开发者编写异步代码，实现非阻塞的并发操作，通过在适当的时候挂起和恢复协程，可以有效地管理多个任务的执行，提高程序的并发性能。与线程相比，协程是轻量级的，它们的创建和上下⽂切换开销较⼩，可以同时执行⼤量的协程，而不会导致系统负载过重，可以在单线程下实现异步，使程序不存在阻塞阶段，充分利用cpu资源。
    2. 简化异步编程逻辑。使用协程可以简化并发编程的复杂性，通过使用适当的协程库或语⾔特性，可以避免显式的线程同步、锁和互斥量等并发编程的常⻅问题，用同步的思想就可以编写成异步的程序。
    缺点：
    3. 最明显的缺点是无法利用多核资源。线程才是系统调度的基本单位，单线程下的多协程本质上还是串行执行的，只能用到单核计算资源，所以协程往往要与多线程、多进程一起使用。

8.
