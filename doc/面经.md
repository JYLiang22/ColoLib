# 协程模块

1. 画一下项目的框架图。
2. 什么是协程？协程和函数都可以调用，它们的区别是什么？协程为什么可以yield、resume？协程和线程有什么区别？

   协程的本质就是函数和函数运行状态的组合 。
   协程和函数的不同之处是，函数一旦被调用，只能从头开始执行，直到函数执行结束退出，而协程则可以执行到一半就退出（称为yield），但此时协程并未真正结束，只是暂时让出CPU执行权，在后面适当的时机协程可以重新恢复运行（称为resume），在这段时间里其他的协程可以获得CPU并运行，所以协程也称为轻量级线程。
   协程能够半路yield、再重新resume的关键是协程存储了函数在yield时间点的执行状态，这个状态称为协程上下文。协程上下文包含了函数在当前执行状态下的全部CPU寄存器的值，这些寄存器值记录了函数栈帧、代码的执行位置等信息，如果将这些寄存器的值重新设置给CPU，就相当于重新恢复了函数的运行。在Linux系统里这个上下文用ucontext_t结构体来表示，通getcontext()来获取。
   协程虽然被称为轻量级线程，但在单线程内，协程并不能并发执行，只能是一个协程结束或yield后，再执行另一个协程，而线程则是可以真正并发执行的。因为单线程下协程并不是并发执行，而是顺序执行的，所以不要在协程里使用线程级别的锁来做协程同步，比如pthread_mutex_t。如果一个协程在持有锁之后让出执行，那么同线程的其他任何协程一旦尝试再次持有这个锁，整个线程就锁死了，这和单线程环境下，连续两次对同一个锁进行加锁导致的死锁道理完全一样。
3. 用通俗的语言介绍下什么是创建协程、协程调度、IO协程调度和定时器？

   所谓创建协程，其实就是把一个函数包装成一个协程对象，然后再用协程的方式把这个函数跑起来；所谓协程调度，其实就是创建一批的协程对象，然后再创建一个调度协程，通过调度协程把这些协程对象一个一个消化掉（协程可以在被调度时继续向调度器添加新的调度任务）；所谓IO协程调度，其实就是在调度协程时，如果发现这个协程在等待IO就绪，那就先让这个协程让出执行权，等对应的IO就绪后再重新恢复这个协程的运行；所谓定时器，就是给调度协程预设一个协程对象，等定时时间到了就恢复预设的协程对象。
4. 你说了基于 u_context 实现了协程类，具体是怎么实现的？u_context的定义和操作函数都有哪些？

   ```cpp
   // 上下文结构体定义
   // 这个结构体是平台相关的，因为不同平台的寄存器不一样
   // 下面列出的是所有平台都至少会包含的4个成员
   typedef struct ucontext_t {
      // 当前上下文结束后，下一个激活的上下文对象的指针，只在当前上下文是由makecontext创建时有效
      struct ucontext_t *uc_link;
      // 当前上下文的信号屏蔽掩码
      sigset_t          uc_sigmask;
      // 当前上下文使用的栈内存空间，只在当前上下文是由makecontext创建时有效
      stack_t           uc_stack;
      // 平台相关的上下文具体内容，包含寄存器的值
      mcontext_t        uc_mcontext;
      ...
   } ucontext_t;

   // 获取当前的上下文
   int getcontext(ucontext_t *ucp);

   // 恢复ucp指向的上下文，这个函数不会返回，而是会跳转到ucp上下文对应的函数中执行，相当于变相调用了函数
   int setcontext(const ucontext_t *ucp);

   // 修改由getcontext获取到的上下文指针ucp，将其与一个函数func进行绑定，支持指定func运行时的参数，
   // 在调用makecontext之前，必须手动给ucp分配一段内存空间，存储在ucp->uc_stack中，这段内存空间将作为func函数运行时的栈空间，
   // 同时也可以指定ucp->uc_link，表示函数运行结束后恢复uc_link指向的上下文，
   // 如果不赋值uc_link，那func函数结束时必须调用setcontext或swapcontext以重新指定一个有效的上下文，否则程序就跑飞了
   // makecontext执行完后，ucp就与函数func绑定了，调用setcontext或swapcontext激活ucp时，func就会被运行
   void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);

   // 恢复ucp指向的上下文，同时将当前的上下文存储到oucp中，
   // 和setcontext一样，swapcontext也不会返回，而是会跳转到ucp上下文对应的函数中执行，相当于调用了函数
   // swapcontext是sylar非对称协程实现的关键，线程主协程和子协程用这个接口进行上下文切换
   int swapcontext(ucontext_t *oucp, const ucontext_t *ucp);
   ```
5. 对称协程和非对称协程、有栈协程和无栈协程区别是什么？

   对称协程，协程可以不受限制地将控制权交给任何其他协程。任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移。
   非对称协程，是指协程之间存在类似堆栈的调用方-被调用方关系。协程出让调度权的目标只能是它的调用者。也就是子协程只能和线程主协程切换，而不能和另一个子协程切换，并且在程序结束时，一定要再切回主协程，以保证程序能正常结束。
   对称协程更灵活，非对称协程实现更简单。在对称协程中，⼦协程可以直接和⼦协程切换，也就是说每个协程不仅要运行自己的入口函数代码，还要负责选出下一个合适的协程进行切换，相当于每个协程都要充当调度器的角色，这样程序设计起来会比较麻烦，并且程序的控制流也会变得复杂和难以管理。而在非对称协程中，可以借助专门的调度器来负责调度协程，每个协程只需要运行自己的入口函数，然后结束时将运行权交回给调度器，由调度器来选出下一个要执行的协程即可。
   有栈协程和无栈协程指的是协程切换的时候用于存储协程上下文的数据结构不一样。
   有栈协程：用独立的执行栈来保存协程的上下⽂信息。当协程被挂起时，栈协程会保存当前执行状态（例如函数调用栈、局部变量等），并将控制权交还给调度器。当协程被恢复时，栈协程会将之前保存的执行状态恢复，从上次挂起的地方继续执行。类似于内核态线程的实现，不同协程间切换还是要切换对应的栈上下文，只是不用陷入内核而已。
   无栈协程：它不需要独立的执行栈来保存协程的上下文信息，协程的上下文都放到公共内存中，当协程被挂起时，无栈协程会将协程的状态保存在堆上的数据结构中，并将控制权交还给调度器。当协程被恢复时，无栈协程会将之前保存的状态从堆中取出，并从上次挂起的地方继续执行。协程切换时，使用状态机来切换，就不用切换对应的上下文了，因为都在堆里的。比有栈协程都要轻量许多。
6. 了解有栈协程中的独立栈和共享栈吗？

   共享栈本质就是所有的协程在运行的时候都使用同一个栈空间，每次协程切换时要把自身用的共享栈空间拷贝。对协程调用 yield 的时候，该协程栈内容暂时保存起来，保存的时候需要用到多少内存就开辟多少，这样就减少了内存的浪费， resume 该协程的时候，协程之前保存的栈内容，会被重新拷贝到运行时栈中。
   独立栈，也就是每个协程的栈空间都是独立的，固定大小。好处是协程切换的时候，内存不用拷贝来拷贝去。坏处则是内存空间浪费。因为栈空间在运行时不能随时扩容，否则如果有指针操作执行了栈内存，扩容后将导致指针失效。为了防止栈内存不够，每个协程都要预先开一个足够的栈空间使用。当然很多协程在实际运行中也用不了这么大的空间，就必然造成内存的浪费和开辟大内存造成的性能损耗。
   独立栈相对简单，但废内存，容易栈溢出。
   共享栈使用公共资源，公共资源内存空间比较大，相对安全，节省内存空间，但是协程频繁切换需要进行内存拷贝，废 CPU。
   项目里的栈是独立栈，因为实现起来比较简单。
7. 协程的优缺点？

   优点：

   1. 提高资源利用率，提高程序并发性能。协程允许开发者编写异步代码，实现非阻塞的并发操作，通过在适当的时候挂起和恢复协程，可以有效地管理多个任务的执行，提高程序的并发性能。与线程相比，协程是轻量级的，它们的创建和上下文切换开销较小，可以同时执行大量的协程，而不会导致系统负载过重，可以在单线程下实现异步，使程序不存在阻塞阶段，充分利用cpu资源。
   2. 简化异步编程逻辑。使用协程可以简化并发编程的复杂性，通过使用适当的协程库或语言特性，可以避免显式的线程同步、锁和互斥量等并发编程的常见问题，用同步的思想就可以编写成异步的程序。

   缺点：

   1. 最明显的缺点是无法利用多核资源。线程才是系统调度的基本单位，单线程下的多协程本质上还是串行执行的，只能用到单核计算资源，所以协程往往要与多线程、多进程一起使用。

# 协程调度模块

1. 什么是协程调度？
   当你有很多协程时，如何把这些协程都消耗掉，这就是协程调度。
2. 为什么需要协程调度？
   如果没有协程调度，对于每个协程，都需要用户手动调用协程的resume方法将协程运行起来，然后等协程运行结束并返回，再运行下一个协程。这种运行协程的方式其实是用户自己在挑选协程执行，相当于用户在充当调度器，显然不够灵活。而且在这种情况下，一个子协程不能运行另一个子协程。当实现了调度器后，子协程可以通过向调度器添加调度任务的方式运行另一个子协程。
3. 调度任务的形式有哪些？
   协程和函数都可以，因为函数也是可执行的对象。
4. 为什么要把调度线程所在线程加入到调度中？
   在实现相同调度能力的情况下(指能够同时调度的协程数量)，线程数越小，线程切换的开销也就越小，效率就更高一些，所以，调度器所在的线程，也应该支持用来执行调度任务。
5. 简述调度器的工作过程。
   运行过程：可以简单地认为，调度器创建后，内部首先会创建一个调度线程池，调度开始后，所有调度线程按顺序从任务队列里取任务执行，调度线程数越多，能够同时调度的任务也就越多，当所有任务都调度完后，调度线程就停下来等新的任务进来。
   添加调度任务的本质就是往调度器的任务队列里塞任务，但是，只添加调度任务是不够的，还应该有一种方式用于通知调度线程有新的任务加进来了，因为调度线程并不一定知道有新任务进来了。
   调度器应该支持停止调度的功能，以便回收调度线程的资源，只有当所有的调度线程都结束后，调度器才算真正停止。
6. 调度器的设计是怎么样的？
   调度器内部维护一个任务队列和一个调度线程池。开始调度后，线程池从任务队列里按顺序取任务执行。当全部任务都执行完了，线程池停止调度，等新的任务进来。添加新任务后，通知线程池有新的任务进来了，线程池重新开始运行调度。停止调度时，各调度线程退出，调度器停止工作。
7. idle如何处理？

最难的点：当调度线程也参与调度时调度协程和主线程切换的情况，即简历中的支持主线程(创建调度器的线程)参与调度。`<br>`
解决方案的关键点在于：`<br>`
子协程和子协程切换导致线程主协程跑飞的关键原因在于，每个线程只有两个线程局部变量用于保存当前的协程上下文信息。也就是说线程任何时候都最多只能知道两个协程的上下文，其中一个是当前正在运行协程的上下文，另一个是线程主协程的上下文，如果子协程和子协程切换，那这两个上下文都会变成子协程的上下文，线程主协程的上下文丢失了，程序也就跑飞了。如果不改变这种局部，就只能线程主协程去充当调度协程，这就相当于又回到了让用户充当调度器的情况。`<br>`
那么，如何改变这种情况呢？其实非常简单，只需要给每个线程增加一个线程局部变量用于保存调度协程的上下文就可以了，这样，每个线程可以同时保存三个协程的上下文，一个是当前正在执行的协程上下文，另一个是线程主协程的上下文，最后一个是调度协程的上下文。有了这三个上下文，协程就可以根据自己的身份来选择和每次和哪个协程进行交换。`<br>`
但是面试的时候可不能说这么简单，毕竟是难点，可以 **[参考](https://www.midlane.top/wiki/pages/viewpage.action?pageId=10060963#id-%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9D%97-%E8%B0%83%E5%BA%A6%E5%8D%8F%E7%A8%8B%E5%88%87%E6%8D%A2%E9%97%AE%E9%A2%98)** ，理解后形成自己的说辞。`<br>`

# I/O协程调度模块

首先，这个模块由两部分组成：

1. 第一部分是对协程调度器的改造，将epoll与协程调度融合，重新实现tickle和idle，并保证原有的功能不变。
2. 第二部分是基于epoll实现IO事件的添加、删除、调度、取消等功能。

会被问到的问题：

1. 为什么需要IO协程调度？
   IO事件调度功能对服务器开发至关重要，因为服务器通常需要处理大量来自客户端的socket fd，使用IO事件调度可以将开发者从判断socket fd是否可读或可写的工作中解放出来，使得程序员只需要关心socket fd的IO操作。
2. 这个模块是怎么设计的？
   对于IO协程调度来说，每次调度都包含一个三元组信息，分别是描述符-事件类型（可读或可写）-回调函数，调度器记录全部需要调度的三元组信息，其中描述符和事件类型用于epoll_wait，回调函数用于协程调度。这个三元组信息在源码上通过FdContext结构体来存储，在执行epoll_wait时通过epoll_event的私有数据指针data.ptr来保存FdContext结构体信息。
   IO协程调度器在idle时会epoll_wait所有注册的fd，如果有fd满足条件，epoll_wait返回，从私有数据中拿到fd的上下文信息，并且执行其中的回调函数。（实际是idle协程只负责收集所有已触发的fd的回调函数并将其加入调度器的任务队列，真正的执行时机是idle协程退出后，调度器在下一轮调度时执行）
3. 如何实现IO事件和定时器的注册和回调？
   背景介绍：
   在高性能网络编程中，服务器需要同时处理成千上万的客户端连接。传统的阻塞 IO 或多线程模型在这种情况下会遇到性能瓶颈。因此，我们需要一种更高效的机制来处理并发 IO，这就是 IO 多路复用技术发挥作用的地方。
   epoll 机制详解：
   epoll 是 Linux 提供的一种高效的 IO 多路复用接口，它通过一种事件驱动的方式，允许服务器端应用程序注册多个 IO 通道（如套接字描述符），然后epoll 会监控这些 IO 通道上的事件（如可读、可写等），并在事件发生时通知应用程序。
   epoll 相较于传统的 select 和 poll 系统调用有显著的性能优势，因为它不需要在每次调用时都传递和检查整个文件描述符集合，而是通过维护一个内部的数据结构来高效地管理事件。
   IOManager 的角色和功能：
   IOManager 是一个负责管理 epoll 实例的组件，它封装了 epoll 的操作，提供了一个简洁的接口用于注册、删除和处理 IO 事件。
   在初始化时，IOManager 会创建一个 epoll 文件描述符，并设置一个 pipe 用于唤醒机制，这样当没有 IO 事件发生时，IOManager 可以阻塞在 epoll_wait 调用上，等待事件的发生。
   事件注册过程：
   当需要监听一个文件描述符上的事件时，我们通过调用 IOManager 的 addEvent 方法来注册事件。这个方法首先会找到或创建一个 FdContext 对象，该对象包含了文件描述符的事件状态和回调信息。
   然后，addEvent 方法会构造一个 epoll_event 结构体，设置事件类型（如 EPOLLIN 表示可读事件，EPOLLOUT 表示可写事件），并将 FdContext 指针作为私有数据传递给 epoll。
   最后，使用 epoll_ctl 调用将文件描述符和事件注册到 epoll 实例中。
   事件回调机制：
   当 epoll_wait 检测到事件时，它会返回一个包含所有就绪事件的列表。IOManager 会遍历这个列表，对于每个发生的事件，通过 epoll_event 结构体中的私有数据找到对应的 FdContext。
   然后，IOManager 会根据 FdContext 中保存的回调函数或协程信息，执行相应的事件处理逻辑。这通常是通过调用一个回调函数或恢复一个之前挂起的协程来完成的。
   事件处理细节：
   在处理事件时，IOManager 需要考虑多种情况，例如当检测到错误事件（EPOLLERR）或挂起事件（EPOLLHUP）时，应该同时触发读和写事件的处理，以确保应用程序能够正确响应这些情况。
   此外，IOManager 还需要在事件处理后更新 epoll 实例中的注册信息，对于已经处理完的事件，可能需要从 epoll 中删除，或者如果还有剩余的事件类型需要关注，则更新事件类型后重新注册。
   取消和删除事件：
   cancelEvent 方法用于在不再需要监听某个事件时取消注册。它会通过 epoll_ctl 调用从 epoll 实例中删除指定的事件，并在删除前触发一次该事件，以确保事件处理的完整性。
   cancelAll 方法用于取消某个文件描述符上所有的事件，并在取消前触发所有已注册的事件。
   总结来说：
   IO协程调度器使用一对管道fd来tickle调度协程，当调度器空闲时，idle协程通过epoll_wait阻塞在管道的读描述符上，等管道的可读事件。添加新任务时，tickle方法写管道，idle协程检测到管道可读后退出，调度器执行调度。
4. 如何基于epoll实现IO事件的添加、删除、调度、取消？
5. 

IO协程调度器使用一对管道fd来tickle调度协程，当调度器空闲时，idle协程通过epoll_wait阻塞在管道的读描述符上，等管道的可读事件。添加新任务时，tickle方法写管道，idle协程检测到管道可读后退出，调度器执行调度。
IO协程调度的过程
