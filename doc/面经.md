# 项目框架图


# 协程模块

1. 什么是协程？协程和函数都可以调用，它们的区别是什么？协程为什么可以yield、resume？协程和线程有什么区别？

   协程的本质就是函数和函数运行状态的组合 。
   协程和函数的不同之处是，函数一旦被调用，只能从头开始执行，直到函数执行结束退出，而协程则可以执行到一半就退出（称为yield），但此时协程并未真正结束，只是暂时让出CPU执行权，在后面适当的时机协程可以重新恢复运行（称为resume），在这段时间里其他的协程可以获得CPU并运行，所以协程也称为轻量级线程。
   协程能够半路yield、再重新resume的关键是协程存储了函数在yield时间点的执行状态，这个状态称为协程上下文。协程上下文包含了函数在当前执行状态下的全部CPU寄存器的值，这些寄存器值记录了函数栈帧、代码的执行位置等信息，如果将这些寄存器的值重新设置给CPU，就相当于重新恢复了函数的运行。在Linux系统里这个上下文用ucontext_t结构体来表示，通getcontext()来获取。
   协程虽然被称为轻量级线程，但在单线程内，协程并不能并发执行，只能是一个协程结束或yield后，再执行另一个协程，而线程则是可以真正并发执行的。因为单线程下协程并不是并发执行，而是顺序执行的，所以不要在协程里使用线程级别的锁来做协程同步，比如pthread_mutex_t。如果一个协程在持有锁之后让出执行，那么同线程的其他任何协程一旦尝试再次持有这个锁，整个线程就锁死了，这和单线程环境下，连续两次对同一个锁进行加锁导致的死锁道理完全一样。
2. 用通俗的语言介绍下什么是创建协程、协程调度、IO协程调度和定时器？

   所谓创建协程，其实就是把一个函数包装成一个协程对象，然后再用协程的方式把这个函数跑起来；所谓协程调度，其实就是创建一批的协程对象，然后再创建一个调度协程，通过调度协程把这些协程对象一个一个消化掉（协程可以在被调度时继续向调度器添加新的调度任务）；所谓IO协程调度，其实就是在调度协程时，如果发现这个协程在等待IO就绪，那就先让这个协程让出执行权，等对应的IO就绪后再重新恢复这个协程的运行；所谓定时器，就是给调度协程预设一个协程对象，等定时时间到了就恢复预设的协程对象。
3. 你说了基于 u_context 实现了协程类，具体是怎么实现的？u_context的定义和操作函数都有哪些？

   ```cpp
   // 上下文结构体定义
   // 这个结构体是平台相关的，因为不同平台的寄存器不一样
   // 下面列出的是所有平台都至少会包含的4个成员
   typedef struct ucontext_t {
      // 当前上下文结束后，下一个激活的上下文对象的指针，只在当前上下文是由makecontext创建时有效
      struct ucontext_t *uc_link;
      // 当前上下文的信号屏蔽掩码
      sigset_t          uc_sigmask;
      // 当前上下文使用的栈内存空间，只在当前上下文是由makecontext创建时有效
      stack_t           uc_stack;
      // 平台相关的上下文具体内容，包含寄存器的值
      mcontext_t        uc_mcontext;
      ...
   } ucontext_t;

   // 获取当前的上下文
   int getcontext(ucontext_t *ucp);

   // 恢复ucp指向的上下文，这个函数不会返回，而是会跳转到ucp上下文对应的函数中执行，相当于变相调用了函数
   int setcontext(const ucontext_t *ucp);

   // 修改由getcontext获取到的上下文指针ucp，将其与一个函数func进行绑定，支持指定func运行时的参数，
   // 在调用makecontext之前，必须手动给ucp分配一段内存空间，存储在ucp->uc_stack中，这段内存空间将作为func函数运行时的栈空间，
   // 同时也可以指定ucp->uc_link，表示函数运行结束后恢复uc_link指向的上下文，
   // 如果不赋值uc_link，那func函数结束时必须调用setcontext或swapcontext以重新指定一个有效的上下文，否则程序就跑飞了
   // makecontext执行完后，ucp就与函数func绑定了，调用setcontext或swapcontext激活ucp时，func就会被运行
   void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);

   // 恢复ucp指向的上下文，同时将当前的上下文存储到oucp中，
   // 和setcontext一样，swapcontext也不会返回，而是会跳转到ucp上下文对应的函数中执行，相当于调用了函数
   // swapcontext是sylar非对称协程实现的关键，线程主协程和子协程用这个接口进行上下文切换
   int swapcontext(ucontext_t *oucp, const ucontext_t *ucp);
   ```

   首先需要了解 `ucontext_t` ，这是一个结构体，包含有一些常见的用于上下文切换的成员，例如下一个激活的上下文对象的指针 `struct ucontext_t *uc_link` ，当前上下文使用的栈内存空间 `stack_t uc_stack` 。
   除此之外，ucontext_t函数族还提供了辅助上下文切换的函数，有如下几个。获取当前上下文的 `int getcontext(ucontext_t *ucp);`，恢复当前上下文的的 `int setcontext(const ucontext_t *ucp);`，把获取的上下文指针和函数进行绑定并支持传参的 `void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);`，交换当前上下文的 `int swapcontext(ucontext_t *oucp, const ucontext_t *ucp);`。
   在这里，基于ucontext_t实现协程类，主要指的是在协程的无参构造函数中使用 `int getcontext(ucontext_t *ucp);` 来获取当前上下文，创建线程的第一个协程，也就是主协程；在协程的有参数构造函数中，通过 `void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);` 把当前上下文和传入的函数进行绑定，用于构建用户协程；同时借助 `int swapcontext(ucontext_t *oucp, const ucontext_t *ucp);` 交换当前上下文实现协程的 yield 和 resume；在重置协程时，先通过 `int getcontext(ucontext_t *ucp);` 来获取当前上下文，之后通过 `void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);` 把当前上下文和传入的函数进行绑定，实现协程重置，重复利用已结束的协程，复用其栈空间，创建新协程。
4. 对称协程和非对称协程、有栈协程和无栈协程区别是什么？

   对称协程，协程可以不受限制地将控制权交给任何其他协程。任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移。
   非对称协程，是指协程之间存在调用方-被调用方关系。协程出让调度权的目标只能是它的调用者。也就是子协程只能和线程主协程切换，而不能和另一个子协程切换，并且在程序结束时，一定要再切回主协程，以保证程序能正常结束。
   对称协程更灵活，非对称协程实现更简单。在对称协程中，⼦协程可以直接和⼦协程切换，也就是说每个协程不仅要运行自己的入口函数代码，还要负责选出下一个合适的协程进行切换，相当于每个协程都要充当调度器的角色，这样程序设计起来会比较麻烦，并且程序的控制流也会变得复杂和难以管理。而在非对称协程中，可以借助专门的调度器来负责调度协程，每个协程只需要运行自己的入口函数，然后结束时将运行权交回给调度器，由调度器来选出下一个要执行的协程即可。
   有栈协程和无栈协程指的是协程切换的时候用于存储协程上下文的数据结构不一样。
   有栈协程：用独立的执行栈来保存协程的上下⽂信息。当协程被挂起时，栈协程会保存当前执行状态（例如函数调用栈、局部变量等），并将控制权交还给调度器。当协程被恢复时，栈协程会将之前保存的执行状态恢复，从上次挂起的地方继续执行。类似于内核态线程的实现，不同协程间切换还是要切换对应的栈上下文，只是不用陷入内核而已。
   无栈协程：它不需要独立的执行栈来保存协程的上下文信息，协程的上下文都放到公共内存中，当协程被挂起时，无栈协程会将协程的状态保存在堆上的数据结构中，并将控制权交还给调度器。当协程被恢复时，无栈协程会将之前保存的状态从堆中取出，并从上次挂起的地方继续执行。协程切换时，使用状态机来切换，就不用切换对应的上下文了，因为都在堆里的。比有栈协程都要轻量许多。
5. 了解有栈协程中的独立栈和共享栈吗？

   共享栈本质就是所有的协程在运行的时候都使用同一个栈空间，每次协程切换时要把自身用的共享栈空间拷贝。对协程调用 yield 的时候，该协程栈内容暂时保存起来，保存的时候需要用到多少内存就开辟多少，这样就减少了内存的浪费， resume 该协程的时候，协程之前保存的栈内容，会被重新拷贝到运行时栈中。
   独立栈，也就是每个协程的栈空间都是独立的，固定大小。好处是协程切换的时候，内存不用拷贝来拷贝去。坏处则是内存空间浪费。因为栈空间在运行时不能随时扩容，否则如果有指针操作执行了栈内存，扩容后将导致指针失效。为了防止栈内存不够，每个协程都要预先开一个足够的栈空间使用。当然很多协程在实际运行中也用不了这么大的空间，就必然造成内存的浪费和开辟大内存造成的性能损耗。
   独立栈相对简单，但废内存，容易栈溢出。
   共享栈使用公共资源，公共资源内存空间比较大，相对安全，节省内存空间，但是协程频繁切换需要进行内存拷贝，废 CPU。
   项目里的栈是独立栈，因为实现起来比较简单。
6. 协程的优缺点？

   优点：

   1. 提高资源利用率，提高程序并发性能。协程允许开发者编写异步代码，实现非阻塞的并发操作，通过在适当的时候挂起和恢复协程，可以有效地管理多个任务的执行，提高程序的并发性能。与线程相比，协程是轻量级的，它们的创建和上下文切换开销较小，可以同时执行大量的协程，而不会导致系统负载过重，可以在单线程下实现异步，使程序不存在阻塞阶段，充分利用cpu资源。
   2. 简化异步编程逻辑。使用协程可以简化并发编程的复杂性，通过使用适当的协程库或语言特性，可以避免显式的线程同步、锁和互斥量等并发编程的常见问题，用同步的思想就可以编写成异步的程序。

   缺点：

   3. 最明显的缺点是无法利用多核资源。线程才是系统调度的基本单位，单线程下的多协程本质上还是串行执行的，只能用到单核计算资源，所以协程往往要与多线程、多进程一起使用。


# 协程调度模块

1. 什么是协程调度？

   当你有很多协程时，如何把这些协程都消耗掉，这就是协程调度。
2. 为什么需要协程调度？

   如果没有协程调度，对于每个协程，都需要用户手动调用协程的resume方法将协程运行起来，然后等协程运行结束并返回，再运行下一个协程。这种运行协程的方式其实是用户自己在挑选协程执行，相当于用户在充当调度器，显然不够灵活。而且在这种情况下，一个子协程不能运行另一个子协程。当实现了调度器后，子协程可以通过向调度器添加调度任务的方式运行另一个子协程。
3. 调度任务的形式有哪些？

   协程和函数都可以，因为函数也是可执行的对象。
4. 为什么要把调度线程所在线程加入到调度中？

   在实现相同调度能力的情况下(指能够同时调度的协程数量)，线程数越小，线程切换的开销也就越小，效率就更高一些，所以，调度器所在的线程，也应该支持用来执行调度任务。
5. 简述调度器的工作过程。

   运行过程：可以简单地认为，调度器创建后，内部首先会创建一个调度线程池，调度开始后，所有调度线程按顺序从任务队列里取任务执行，调度线程数越多，能够同时调度的任务也就越多，当所有任务都调度完后，调度线程就停下来等新的任务进来。
   添加调度任务的本质就是往调度器的任务队列里塞任务，但是，只添加调度任务是不够的，还应该有一种方式用于通知调度线程有新的任务加进来了，因为调度线程并不一定知道有新任务进来了。
   调度器应该支持停止调度的功能，以便回收调度线程的资源，只有当所有的调度线程都结束后，调度器才算真正停止。
6. 调度器的设计是怎么样的？

   调度器内部维护一个任务队列和一个调度线程池。开始调度后，线程池从任务队列里按顺序取任务执行。当全部任务都执行完了，线程池停止调度，等新的任务进来。添加新任务后，通知线程池有新的任务进来了，线程池重新开始运行调度。停止调度时，各调度线程退出，调度器停止工作。
7. idle如何处理？

最难的点：当调度线程也参与调度时调度协程和主线程切换的情况，即简历中的支持主线程(创建调度器的线程)参与调度。`<br>`
解决方案的关键点在于：`<br>`
子协程和子协程切换导致线程主协程跑飞的关键原因在于，每个线程只有两个线程局部变量用于保存当前的协程上下文信息。也就是说线程任何时候都最多只能知道两个协程的上下文，其中一个是当前正在运行协程的上下文，另一个是线程主协程的上下文，如果子协程和子协程切换，那这两个上下文都会变成子协程的上下文，线程主协程的上下文丢失了，程序也就跑飞了。如果不改变这种局部，就只能线程主协程去充当调度协程，这就相当于又回到了让用户充当调度器的情况。`<br>`
那么，如何改变这种情况呢？其实非常简单，只需要给每个线程增加一个线程局部变量用于保存调度协程的上下文就可以了，这样，每个线程可以同时保存三个协程的上下文，一个是当前正在执行的协程上下文，另一个是线程主协程的上下文，最后一个是调度协程的上下文。有了这三个上下文，协程就可以根据自己的身份来选择和每次和哪个协程进行交换。`<br>`
但是面试的时候可不能说这么简单，毕竟是难点，可以 **[参考](https://www.midlane.top/wiki/pages/viewpage.action?pageId=10060963#id-%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9D%97-%E8%B0%83%E5%BA%A6%E5%8D%8F%E7%A8%8B%E5%88%87%E6%8D%A2%E9%97%AE%E9%A2%98)** ，理解后形成自己的说辞。`<br>`


# I/O协程调度模块

首先，这个模块由两部分组成：

1. 第一部分是对协程调度器的改造，将epoll与协程调度融合，重新实现tickle和idle，并保证原有的功能不变。
2. 第二部分是基于epoll实现IO事件的添加、删除、调度、取消等功能。

会被问到的问题：

1. 为什么需要IO协程调度？

   IO事件调度功能对服务器开发至关重要，因为服务器通常需要处理大量来自客户端的socket fd，使用IO事件调度可以将开发者从判断socket fd是否可读或可写的工作中解放出来，使得程序员只需要关心socket fd的IO操作。
2. 这个模块是怎么设计的？

   对于IO协程调度来说，每次调度都包含一个三元组信息，分别是描述符-事件类型（可读或可写）-回调函数，调度器记录全部需要调度的三元组信息，其中描述符和事件类型用于epoll_wait，回调函数用于协程调度。这个三元组信息在源码上通过FdContext结构体来存储，在执行epoll_wait时通过epoll_event的私有数据指针data.ptr来保存FdContext结构体信息。
   IO协程调度器在idle时会epoll_wait所有注册的fd，如果有fd满足条件，epoll_wait返回，从私有数据中拿到fd的上下文信息，并且执行其中的回调函数。（实际是idle协程只负责收集所有已触发的fd的回调函数并将其加入调度器的任务队列，真正的执行时机是idle协程退出后，调度器在下一轮调度时执行）
3. 如何实现IO事件和定时器的注册和回调？

   背景介绍：
   在高性能网络编程中，服务器需要同时处理成千上万的客户端连接。传统的阻塞 IO 或多线程模型在这种情况下会遇到性能瓶颈。因此，我们需要一种更高效的机制来处理并发 IO，这就是 IO 多路复用技术发挥作用的地方。
   epoll 机制详解：
   epoll 是 Linux 提供的一种高效的 IO 多路复用接口，它通过一种事件驱动的方式，允许服务器端应用程序注册多个 IO 通道（如套接字描述符），然后epoll 会监控这些 IO 通道上的事件（如可读、可写等），并在事件发生时通知应用程序。
   epoll 相较于传统的 select 和 poll 系统调用有显著的性能优势，因为它不需要在每次调用时都传递和检查整个文件描述符集合，而是通过维护一个内部的数据结构来高效地管理事件。
   IOManager 的角色和功能：
   IOManager 是一个负责管理 epoll 实例的组件，它封装了 epoll 的操作，提供了一个简洁的接口用于注册、删除和处理 IO 事件。
   在初始化时，IOManager 会创建一个 epoll 文件描述符，并设置一个 pipe 用于唤醒机制，这样当没有 IO 事件发生时，IOManager 可以阻塞在 epoll_wait 调用上，等待事件的发生。
   事件注册过程：
   当需要监听一个文件描述符上的事件时，我们通过调用 IOManager 的 addEvent 方法来注册事件。这个方法首先会找到或创建一个 FdContext 对象，该对象包含了文件描述符的事件状态和回调信息。
   然后，addEvent 方法会构造一个 epoll_event 结构体，设置事件类型（如 EPOLLIN 表示可读事件，EPOLLOUT 表示可写事件），并将 FdContext 指针作为私有数据传递给 epoll。
   最后，使用 epoll_ctl 调用将文件描述符和事件注册到 epoll 实例中。
   事件回调机制：
   当 epoll_wait 检测到事件时，它会返回一个包含所有就绪事件的列表。IOManager 会遍历这个列表，对于每个发生的事件，通过 epoll_event 结构体中的私有数据找到对应的 FdContext。
   然后，IOManager 会根据 FdContext 中保存的回调函数或协程信息，执行相应的事件处理逻辑。这通常是通过调用一个回调函数或恢复一个之前挂起的协程来完成的。
   事件处理细节：
   在处理事件时，IOManager 需要考虑多种情况，例如当检测到错误事件（EPOLLERR）或挂起事件（EPOLLHUP）时，应该同时触发读和写事件的处理，以确保应用程序能够正确响应这些情况。
   此外，IOManager 还需要在事件处理后更新 epoll 实例中的注册信息，对于已经处理完的事件，可能需要从 epoll 中删除，或者如果还有剩余的事件类型需要关注，则更新事件类型后重新注册。
   取消和删除事件：
   cancelEvent 方法用于在不再需要监听某个事件时取消注册。它会通过 epoll_ctl 调用从 epoll 实例中删除指定的事件，并在删除前触发一次该事件，以确保事件处理的完整性。
   cancelAll 方法用于取消某个文件描述符上所有的事件，并在取消前触发所有已注册的事件。
   总结来说：
   IO协程调度器使用一对管道fd来tickle调度协程，当调度器空闲时，idle协程通过epoll_wait阻塞在管道的读描述符上，等管道的可读事件。添加新任务时，tickle方法写管道，idle协程检测到管道可读后退出，调度器执行调度。
4. 如何基于epoll实现IO事件的添加、删除、调度、取消？
5. 

IO协程调度器使用一对管道fd来tickle调度协程，当调度器空闲时，idle协程通过epoll_wait阻塞在管道的读描述符上，等管道的可读事件。添加新任务时，tickle方法写管道，idle协程检测到管道可读后退出，调度器执行调度。
IO协程调度的过程


# 定时器模块

1. 管理定时器的容器的选择？

   在设计用于调度或管理事件的高效计时器时，有几种常用的数据结构：**升序链表**、**时间轮**和**最小堆**。每种结构都有自己的设计特点、优点和权衡，具体取决于用例。

   1. **升序链表**

      设计：**升序链表**将计时器组织在一个排序列表中，其中每个节点代表一个计时器，计时器按其到期时间排序。列表的头部始终保存下一个到期的计时器。

      优点：

      - **易于实现**：它具有直观的设计，尤其是对于少量计时器。
      - **快速检索最近的计时器**：列表中的第一个元素是下一个到期的计时器，因此很容易找到。

      缺点：

      - **插入成本**：插入新计时器需要扫描列表以找到正确位置（最坏情况下的复杂度为 O(n)）。
      - **可扩展性问题**：随着计时器数量的增加，插入的开销会显著增加。

      用例：

      - 适用于**计时器数量较少**且插入很少发生的系统。
   2. **时间轮**

      设计：**时间轮**是一个循环数组，其中每个槽代表一个时间单位（例如，毫秒或秒）。每个槽包含一个链接的计时器列表，这些计时器设置为在等于槽索引的时间偏移处到期。随着时间的推移，指针围绕轮子移动，激活为当前槽安排的任何计时器。

      优点：

      - **高效的时间跟踪**：检查和触发计时器的复杂度是恒定的（O(1)），因为您只需移动指针并检查当前时隙即可。
      - **插入成本低**：插入新计时器涉及计算其与当前时间的偏移量并将其放置在适当的时隙中，即 O(1)。

      缺点：

      - **分辨率限制**：计时器的精度受到时间轮时隙粒度的限制。
      - **长计时器**：处理比时间轮总跨度更长的计时器（环绕式计时器）需要额外的逻辑，这会使设计复杂化。

      用例：

      - 非常适合具有**许多计时器**和频繁事件的系统，尤其是在计时器精度要求不严格的情况下。示例包括网络系统和事件驱动架构。
   3. **最小堆**

      设计：**最小堆**将计时器组织为二叉堆，其中最早到期的计时器始终位于根部。插入和删除保持堆属性。

      优点：

      - **高效提取**：提取下一个到期的计时器需要 O(log n)，与链表相比效率更高。
      - **平衡插入和删除**：插入和删除操作的时间复杂度均为 O(log n)。

      缺点：

      - **实现更复杂**：管理堆比链表或时间轮更复杂。
      - **插入比时间轮慢**：与时间轮的恒定时间插入相比，O(log n) 插入可能很慢。

      使用案例：

      - 适用于具有**大量定时器**的系统，这些系统需要高效插入和检索具有不同到期时间的定时器。
   4. 如何选择：

      1. **定时器数量**：

      - 如果只有几个定时器，则升序链表就足够了。
      - 对于**许多定时器**，最好使用时间轮或最小堆。

      2. **精度要求**：

      - 如果定时器精度很重要，则最小堆可以更精细地控制定时器到期。
      - 如果可以接受粗粒度的精度，则时间轮效率更高。

      3. **定时器分布**：

      - 如果定时器紧密聚集，则升序链表可能有效。
      - 对于随机或高度分布的定时器，最小堆效果很好。
      - 当定时器在可预测的间隔内均匀分布时，时间轮更适合。

      4. **系统约束**：

      - 需要处理大量计时器（例如，网络堆栈或游戏引擎）的时间关键型系统通常会受益于时间轮的 O(1) 性能。
      - 处理零星或不频繁计时器的系统可能更喜欢上升链表的简单性。
2. 最小堆是如何定义的？

   这里并没有自定义一个堆，而是使用 `std::set` 实现的最小堆，具体 `std::set<Timer::ptr, Timer::Comparator> m_timers;` 实现是通过往set的参数里面传递一个自定义的比较函数 `Comparator()`，这个函数需要传入两个要比较的定时器作为参数。
3. 定时器是如何执行定时任务的？

   IO协程调度器的idle协程会在调度器空闲时阻塞在epoll_wait上，等待IO事件发生。加入定时器功能前，epoll_wait具有固定的超时时间，这个值是5秒钟。加入定时器功能后，epoll_wait的超时时间改用当前定时器的最小超时时间来代替。epoll_wait返回后，根据当前的绝对时间把已超时的所有定时器收集起来，执行它们的回调函数。
   由于epoll_wait的返回并不一定是超时引起的，也有可能是IO事件唤醒的，所以在epoll_wait返回后不能想当然地假设定时器已经超时了，而是要再判断一下定时器有没有超时，这时绝对时间的好处就体现出来了，通过比较当前的绝对时间和定时器的绝对超时时间，就可以确定一个定时器到底有没有超时。
4. 为什么使用绝对时间而不适用相对时间进行超时的比较？

   1. **绝对时间**

      - **定义**：绝对时间是指系统时间线上的特定点，通常使用当前系统时钟或标准时间参考（如 Unix 纪元时间）来定义。事件计划在某个确切的时间点触发，例如**下午 3:00**或**1623840000（Unix 时间戳）**。

      优点：

      - **可预测性**：计时器与特定的真实时间相关联。如果多个系统需要同步其事件，绝对时间可确保它们在同一时刻发生。
      - **重启之间的一致性**：系统重启或从暂停状态恢复后，绝对时间仍然有效。这在精确的事件执行时间很重要的场景中很有用，例如金融交易或系统备份。

      缺点：

      - **系统时钟依赖性**：如果系统时钟发生变化（由于与时间服务器同步、手动调整等），使用绝对时间的计时器可能会触发得太早或太晚。
      - **更复杂的逻辑**：在为绝对未来时间设置计时器时，系统必须计算距离当前时间的未来时间有多远，这增加了处理计时器队列的复杂性。
      - **时区或夏令时变化的困难**：处理跨不同时区或夏令时变化期间的绝对时间可能会带来复杂性。

      用例：

      - **实时系统**需要在特定时刻触发事件，无论计时器何时设置。
      - **分布式系统**，其中多个节点或机器需要同时触发同一事件（例如，分布式数据库或 IoT 设备）。
   2. **相对时间**

      - **定义**：相对时间指定事件应触发的持续时间或间隔。计时器被定义为“从现在起的 X 个单位”，例如“从现在起 5 秒触发事件”。

      优点：

      - **使用简单**：它仅取决于自设置计时器以来经过的时间，因此系统无需担心实际时间。
      - **不依赖系统时钟**：系统时钟的变化（例如，夏令时或手动调整）不会影响使用相对时间设置的计时器。
      - **开销较低**：由于相对时间只关心从现在起的持续时间，因此计算和管理起来很简单。

      缺点：

      - **易受系统暂停或重启的影响**：如果系统暂停、暂停或重启，基于相对时间的计时器可能会延迟甚至丢失，除非有额外的逻辑处理这些事件的持久性。
      - **事件时间不一致**：如果系统过载或计时器队列未及时处理，相对计时器可能无法准时触发，从而导致事件执行出现偏差或延迟。

      用例：

      - 适用于**简单的调度任务**，您不关心实际时间，只需要在一定时间后执行操作。
      - 用于**超时机制**、**去抖动事件**或**重试机制**等情况，其中只关心延迟而不是绝对时间。
5. 传入的是绝对时间还是相对时间？

   传入的是相对时间，但会在Timer初始化或者refresh Timer的时候把相对时间转化为绝对时间，通过使用 `clock_gettime` 和 `CLOCK_MONOTONIC_RAW` 获取当前时间，再把当前时间和传入的相对时间相加，获取超时的绝对时间。
6. 你之前说过，在加入定时器后使用的是目前最小的超时时间，如果新插入的定时器的超时时间比当前最小的定时器还要小，应该如何处理？

   我在 `addTimer` 进行了判断，如果当前插入定时器比当前最小定时器超时时间还要小，那么就会执行 `onTimerInsertedAtFront()` 函数，这个函数会调用 `tickle()` 。由于epoll_wait会检查是否超时，发现目前的定时器没有超时且没有IO事件发生，所以epoll_wait仅仅会会立即退出，并重新从TimerManager中获取最近的超时时间，这时拿到的超时时间就是新添加的最小定时器的超时时间了。
