# 参考

1. [一文看懂Go语言协程的设计与原理](https://juejin.cn/post/7044741465930465311#heading-12)
2. [微信开源C++Libco介绍与应用（一）](https://zhuanlan.zhihu.com/p/51078499)
3. [微信开源C++Libco介绍与应用（二）](https://zhuanlan.zhihu.com/p/51081816)


# go协程

可以用来回答“了解go的协程吗？”这个问题。<br>

Go语言最大的特色就是从语言层面支持并发（Goroutine），Goroutine是Go中最基本的执行单元。事实上每一个Go程序至少有一个Goroutine：main Goroutine。Go 程序从 main 包的 main() 函数开始，在程序启动时，Go 程序就会为 main() 函数创建一个默认的 goroutine。<br>
Go 语言的调度器通过使用与 CPU 数量相等的线程减少线程频繁切换的内存开销，同时在每一个线程上执行额外开销更低的 Goroutine 来降低操作系统和硬件的负载。从go的发展来看，存在两种协程模型。<br>
最开始出现的是G-M模型，其中G指Goroutine，本质上是轻量级线程，包括了调用栈；M指Machine，一个M关联一个内核OS线程，由操作系统管理。M(内核线程)想要执行、放回G都必须访问全局G队列，并且M有多个，即多线程访问同一资源需要加锁进行保证互斥/同步，所以全局G队列是有互斥锁进行保护的。<br>
这个调度器有几个缺点：

- 存在单一全局互斥锁和集中状态。全局锁保护所有 goroutine 相关操作（如：创建、完成、重新调度等），导致锁竞争问题严重；
- goroutine 传递问题：经常在 M 之间传递“可运行”的 goroutine，这导致调度延迟增大；
- 每个线程 M 都需要做内存缓存（M.mcache），导致内存占用过高，且数据局部性较差；
- 系统调用频繁地阻塞和解除阻塞正在运行的线程，导致额外的性能损耗。

所以出现了G-P-M模型，新的协程调度器引入了P(Processor)，成为了完善的GPM模型。Processor，它包含了运行goroutine的资源，如果线程想运行goroutine，必须先获取P，P中还包含了可运行的G队列。简单的来说，一个G的执行需要M和P的支持。一个M在与一个P关联之后形成了一个有效的G运行环境【内核线程 + 上下文环境】。每个P都会包含一个可运行的G的队列 (runq )。<br>
各个模块作用如下：

- 全局队列：存放等待运行G；
- P的本地队列：和全局队列类似，存放的也是等待运行的G，存放数量上限256个。新建G时，G优先加入到P的本地队列，如果队列满了，则会把本地队列中的一半G移动到全局队列；
- P列表：所有的P都在程序启动时创建，保存在数组中，最多有GOMAXPROCS个，可通过runtime.GOMAXPROCS(N)修改，N表示设置的个数；
- M：每个M代表一个内核线程，操作系统调度器负责把内核线程分配到CPU的核心上执行。

go语言的协程调度器的核心思想是尽可能避免频繁的创建、销毁线程，对线程进行复用以提高效率。所以采取的是窃取式调度策略，即当本线程无G可运行时，从其他线程绑定的P窃取G，而不是直接销毁线程。<br>
全局G队列的作用在于当M执行窃取式调度策略从其他P窃取不到G时，才会去全局G队列获取G。它是有互斥锁保护的，访问需要竞争锁，新的调度器通过窃取调度策略将其功能弱化了，避免了锁竞争严重的情况出现。<br>
同时为了避免协程阻塞问题，go协程采取时间片策略：一个goroutine最多占用CPU 10ms，防止其他goroutine等待太久得不到执行被“饿死”。<br>


