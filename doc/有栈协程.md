# 参考

1. [一文看懂Go语言协程的设计与原理](https://juejin.cn/post/7044741465930465311#heading-12)
2. [微信开源C++Libco介绍与应用（一）](https://zhuanlan.zhihu.com/p/51078499)
3. [微信开源C++Libco介绍与应用（二）](https://zhuanlan.zhihu.com/p/51081816)


# go协程

可以用来回答“了解go的协程吗？”这个问题。<br>

Go语言最大的特色就是从语言层面支持并发（Goroutine），Goroutine是Go中最基本的执行单元。事实上每一个Go程序至少有一个Goroutine：main Goroutine。Go 程序从 main 包的 main() 函数开始，在程序启动时，Go 程序就会为 main() 函数创建一个默认的 goroutine。<br>
Go 语言的调度器通过使用与 CPU 数量相等的线程减少线程频繁切换的内存开销，同时在每一个线程上执行额外开销更低的 Goroutine 来降低操作系统和硬件的负载。从go的发展来看，存在两种协程模型。<br>
最开始出现的是G-M模型，其中G指Goroutine，本质上是轻量级线程，包括了调用栈；M指Machine，一个M关联一个内核OS线程，由操作系统管理。M(内核线程)想要执行、放回G都必须访问全局G队列，并且M有多个，即多线程访问同一资源需要加锁进行保证互斥/同步，所以全局G队列是有互斥锁进行保护的。<br>
这个调度器有几个缺点：

- 存在单一全局互斥锁和集中状态。全局锁保护所有 goroutine 相关操作（如：创建、完成、重新调度等），导致锁竞争问题严重；
- goroutine 传递问题：经常在 M 之间传递“可运行”的 goroutine，这导致调度延迟增大；
- 每个线程 M 都需要做内存缓存（M.mcache），导致内存占用过高，且数据局部性较差；
- 系统调用频繁地阻塞和解除阻塞正在运行的线程，导致额外的性能损耗。

所以出现了G-P-M模型，新的协程调度器引入了P(Processor)，成为了完善的GPM模型。Processor，它包含了运行goroutine的资源，如果线程想运行goroutine，必须先获取P，P中还包含了可运行的G队列。简单的来说，一个G的执行需要M和P的支持。一个M在与一个P关联之后形成了一个有效的G运行环境【内核线程 + 上下文环境】。每个P都会包含一个可运行的G的队列 (runq )。<br>
各个模块作用如下：

- 全局队列：存放等待运行G；
- P的本地队列：和全局队列类似，存放的也是等待运行的G，存放数量上限256个。新建G时，G优先加入到P的本地队列，如果队列满了，则会把本地队列中的一半G移动到全局队列；
- P列表：所有的P都在程序启动时创建，保存在数组中，最多有GOMAXPROCS个，可通过runtime.GOMAXPROCS(N)修改，N表示设置的个数；
- M：每个M代表一个内核线程，操作系统调度器负责把内核线程分配到CPU的核心上执行。

go语言的协程调度器的核心思想是尽可能避免频繁的创建、销毁线程，对线程进行复用以提高效率。所以采取的是窃取式调度策略，即当本线程无G可运行时，从其他线程绑定的P窃取G，而不是直接销毁线程。<br>
全局G队列的作用在于当M执行窃取式调度策略从其他P窃取不到G时，才会去全局G队列获取G。它是有互斥锁保护的，访问需要竞争锁，新的调度器通过窃取调度策略将其功能弱化了，避免了锁竞争严重的情况出现。<br>
同时为了避免协程阻塞问题，go协程采取时间片策略：一个goroutine最多占用CPU 10ms，防止其他goroutine等待太久得不到执行被“饿死”。<br>


# libco

## 三要素

参考线程，每一个线程的三要素如下：

1. 有一段程序供其执行；
2. 线程专属的系统堆栈空间；
3. 有TCB，线程控制块。在 Linux 内核里，则为 task_struct 的一个结构体。有了这个数据结构，线程才能成为内核调度的一个基本单位接受内核调度。这个结构也记录着线程占有的各项资源。

所以协程对应也需要有三要素：

1. 我们得准备一段程序供协程执行，这即是 co_create() 函数在创建协程的时候传入的第三个参数——形参为 void*，返回值为 void 的一个函数。
2. 用户级线程（协程）没有自己专属的堆空间，只有栈空间。栈内存用于保存调用函数过程中的临时变量，以及函数调用链（栈帧）。
3. co_create() 调用成功后，将返回一个 stCoRoutine_t 的结构指针（第一个参数）。从命名上也可以看出来，该结构即代表了 libco 的协程，记录着一个协程拥有的各种资源。

## 关键数据结构及关系

### 协程控制块 stCoRoutine_t

指定了协程执行的环境，不同于go语言GPM模型，libco的协程一旦创建就和创建的线程绑定了，不支持在不同线程之间迁移。这个 env，即同属于一个线程所有协程的执行环境，包括了当前运行协程、上次切换挂起的协程、嵌套调用的协程栈。[具体可见](#env)<br>
同时还定义了保存协程上下文的变量。<br>
还定义了协程运行时的栈内存，大小固定为128KB。libco号称支持百万级高并发，那么就需要122GB的内存，这样明显和轻量级有矛盾了。这里就涉及到了libco的实现了，它是有栈协程，有栈协程又可以分为独立栈和共享栈。前者为每一个协程分配一个单独的、固定大小的栈；后者仅为正在运行的协程分配栈内存，当协程被切换出去时，就把它实际占用的栈内存 copy 保存到一个单独分配的缓冲区；当被切出去的协程再次调度执行时，再一次 copy 将原来保存的栈内存恢复到那个共享的、固定大小的栈内存空间。<br>
由于二八定律的存在，大多数协程实际使用的栈空间都要比预分配的128KB要小，在这种情况下使用共享栈所占用的内存就会少很多，但随之而来的就是协程切换时拷贝内存的开销比较大。libco两种方式都设计了，默认使用独立栈。

### stCoRoutineEnv_t 结构

<span id="env">前面提到的env的类型是stCoRoutineEnv_t</span>，这里面包含了非对称协程调度关系的调用栈CallStack，用于保存协程之间的调用链；同时还有表示调用栈大小的变量CallStackSize。还定义了两个指针，记录了使用共享栈情况下，协程切换时占有共享栈的协程(ocupy_co)和将要切换的协程(pending_co)，如果没使用共享栈则两者为空指针。
