# 什么是协程

在开始介绍C++协程特性之前，应该了解一下协程。<br>
我们可以简单的认为：协程就是用户态的线程，但是上下文切换的时机是靠调用方（写代码的开发人员）自身去控制的。那么问题来了，既然出现了线程，为什么还需要协程呢？<br>
因为有些时候我们在执行一些操作（尤其是IO操作）时，不希望去做“创建一个新的线程”这种重量级的操作来异步处理。而是希望：在当前线程执行中，暂时切换到其他任务中执行，同时在IO真正准备好了之后，再切换回来继续执行！<br>
相比于多开一个线程来操作，使用协程的好处：<br>

1. 减少了线程的重复高频创建；
2. 尽量避免线程的阻塞；
3. 提升代码的可维护与可理解性（毕竟不需要考虑多线程那一套东西了）。


# 协程的类别

有栈协程和无栈协程：

- 有栈（stackful）协程：用独立的执行栈来保存协程的上下文信息，这类协程的实现类似于内核态线程的实现，不同协程间切换还是要切换对应的栈上下文，只是不用陷入内核而已；例如：**goroutine、libco**；
- 无栈（stackless）协程：无栈协程的上下文都会放到公共内存中，在协程切换时使用状态机来切换，而不用切换对应的上下文（因为都已经在堆中了），因此相比有栈协程要轻量许多；例如：**C++20、Rust、JavaScript 中的协程**。

其中有栈协程又可以分为独立栈和共享栈：

- 共享栈本质就是所有的协程在运行的时候都使用同一个栈空间，每次协程切换时要把自身用的共享栈空间拷贝。对协程调用 yield 的时候，该协程栈内容暂时保存起来，保存的时候需要用到多少内存就开辟多少，这样就减少了内存的浪费， resume 该协程的时候，协程之前保存的栈内容，会被重新拷贝到运行时栈中。
- 独立栈，也就是每个协程的栈空间都是独立的，固定大小。好处是协程切换的时候，内存不用拷贝来拷贝去。坏处则是内存空间浪费。因为栈空间在运行时不能随时扩容，否则如果有指针操作执行了栈内存，扩容后将导致指针失效。为了防止栈内存不够，每个协程都要预先开一个足够的栈空间使用。当然很多协程在实际运行中也用不了这么大的空间，就必然造成内存的浪费和开辟大内存造成的性能损耗。

根据协程之间是否有明显的调用关系，我们又可以把协程分为对称协程和非对称协程：

- 非对称协程：协程之间有明显的调用关系；
- 对称协程：协程之间无明显的调用关系。
